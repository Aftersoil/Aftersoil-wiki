<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS 正则表达式 | 后土维基</title>
    <meta name="generator" content="VuePress 1.6.0">
    <link rel="icon" href="/favicon.ico">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icon/chrome-192x192.png">
    <script>
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?69622073a8649e8a707a918060cc1abc";
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();
      </script>
    <meta name="description" content="后土维基 | 后土文档 | Aftersoil | Aftersoil-wiki">
    <meta name="theme-color" content="#663403">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="baidu-site-verification" content="code-6uTgqJ41VJ">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta HTTP-EQUIV="pragma" content="no-cache">
    <meta HTTP-EQUIV="Cache-Control" content="no-store, must-revalidate">
    <meta HTTP-EQUIV="expires" content="Wed, 26 Feb 1997 08:21:57 GMT">
    <meta HTTP-EQUIV="expires" content="0">
    <link rel="preload" href="/assets/css/0.styles.5dc1cf24.css" as="style"><link rel="preload" href="/assets/js/app.4f367505.js" as="script"><link rel="preload" href="/assets/js/2.cfe6598b.js" as="script"><link rel="preload" href="/assets/js/84.81e6ba36.js" as="script"><link rel="preload" href="/assets/js/3.fb60532c.js" as="script"><link rel="prefetch" href="/assets/js/10.02805980.js"><link rel="prefetch" href="/assets/js/100.c765876e.js"><link rel="prefetch" href="/assets/js/101.f0673ec8.js"><link rel="prefetch" href="/assets/js/102.42575578.js"><link rel="prefetch" href="/assets/js/103.afff93cc.js"><link rel="prefetch" href="/assets/js/104.138d5b5c.js"><link rel="prefetch" href="/assets/js/105.968910dc.js"><link rel="prefetch" href="/assets/js/106.28b32d4c.js"><link rel="prefetch" href="/assets/js/107.aaa21473.js"><link rel="prefetch" href="/assets/js/108.bceb26e0.js"><link rel="prefetch" href="/assets/js/109.63cd14b0.js"><link rel="prefetch" href="/assets/js/11.5c70cba3.js"><link rel="prefetch" href="/assets/js/110.1f0458ce.js"><link rel="prefetch" href="/assets/js/12.0bb4c5bf.js"><link rel="prefetch" href="/assets/js/13.5eddee4b.js"><link rel="prefetch" href="/assets/js/14.0262b500.js"><link rel="prefetch" href="/assets/js/15.8f1c2393.js"><link rel="prefetch" href="/assets/js/16.181ba6ff.js"><link rel="prefetch" href="/assets/js/17.69b5b435.js"><link rel="prefetch" href="/assets/js/18.749ee5d7.js"><link rel="prefetch" href="/assets/js/19.cbee48b0.js"><link rel="prefetch" href="/assets/js/20.0c2bef5a.js"><link rel="prefetch" href="/assets/js/21.9c41aff3.js"><link rel="prefetch" href="/assets/js/22.642684cd.js"><link rel="prefetch" href="/assets/js/23.1b5147ba.js"><link rel="prefetch" href="/assets/js/24.1664e18a.js"><link rel="prefetch" href="/assets/js/25.7ca8fd9a.js"><link rel="prefetch" href="/assets/js/26.70bc6223.js"><link rel="prefetch" href="/assets/js/27.a1091949.js"><link rel="prefetch" href="/assets/js/28.d00f916c.js"><link rel="prefetch" href="/assets/js/29.d376eb2a.js"><link rel="prefetch" href="/assets/js/30.470b2a76.js"><link rel="prefetch" href="/assets/js/31.f09e668a.js"><link rel="prefetch" href="/assets/js/32.2b84ea5d.js"><link rel="prefetch" href="/assets/js/33.044823fc.js"><link rel="prefetch" href="/assets/js/34.504f9a9d.js"><link rel="prefetch" href="/assets/js/35.15eb8085.js"><link rel="prefetch" href="/assets/js/36.db494491.js"><link rel="prefetch" href="/assets/js/37.36d6230b.js"><link rel="prefetch" href="/assets/js/38.ff45be7b.js"><link rel="prefetch" href="/assets/js/39.182b5a48.js"><link rel="prefetch" href="/assets/js/4.20ddffa3.js"><link rel="prefetch" href="/assets/js/40.b8a33dc8.js"><link rel="prefetch" href="/assets/js/41.3de355f5.js"><link rel="prefetch" href="/assets/js/42.477687f5.js"><link rel="prefetch" href="/assets/js/43.f1363e9e.js"><link rel="prefetch" href="/assets/js/44.a36b0e38.js"><link rel="prefetch" href="/assets/js/45.bdabafa3.js"><link rel="prefetch" href="/assets/js/46.17b57ec8.js"><link rel="prefetch" href="/assets/js/47.1b29d52d.js"><link rel="prefetch" href="/assets/js/48.8c4cbe8a.js"><link rel="prefetch" href="/assets/js/49.1bc1f7f0.js"><link rel="prefetch" href="/assets/js/5.597b3655.js"><link rel="prefetch" href="/assets/js/50.c801b6ae.js"><link rel="prefetch" href="/assets/js/51.42f4121d.js"><link rel="prefetch" href="/assets/js/52.e82c65f0.js"><link rel="prefetch" href="/assets/js/53.3225a4fc.js"><link rel="prefetch" href="/assets/js/54.c2fe3548.js"><link rel="prefetch" href="/assets/js/55.89322194.js"><link rel="prefetch" href="/assets/js/56.ca98c4fd.js"><link rel="prefetch" href="/assets/js/57.69ddaf01.js"><link rel="prefetch" href="/assets/js/58.326766c3.js"><link rel="prefetch" href="/assets/js/59.a5257216.js"><link rel="prefetch" href="/assets/js/6.716bb8d3.js"><link rel="prefetch" href="/assets/js/60.1fce2c83.js"><link rel="prefetch" href="/assets/js/61.c98c5914.js"><link rel="prefetch" href="/assets/js/62.b17ee2bc.js"><link rel="prefetch" href="/assets/js/63.6204be46.js"><link rel="prefetch" href="/assets/js/64.d70e9304.js"><link rel="prefetch" href="/assets/js/65.83834113.js"><link rel="prefetch" href="/assets/js/66.7fc2f42c.js"><link rel="prefetch" href="/assets/js/67.ebd98af2.js"><link rel="prefetch" href="/assets/js/68.7ea38251.js"><link rel="prefetch" href="/assets/js/69.23a35c5f.js"><link rel="prefetch" href="/assets/js/7.7578dc10.js"><link rel="prefetch" href="/assets/js/70.5a410861.js"><link rel="prefetch" href="/assets/js/71.aa0b8ac6.js"><link rel="prefetch" href="/assets/js/72.147c8870.js"><link rel="prefetch" href="/assets/js/73.c023c28c.js"><link rel="prefetch" href="/assets/js/74.37955f8f.js"><link rel="prefetch" href="/assets/js/75.3bbdfbe4.js"><link rel="prefetch" href="/assets/js/76.0c31af94.js"><link rel="prefetch" href="/assets/js/77.7991751d.js"><link rel="prefetch" href="/assets/js/78.9fce5924.js"><link rel="prefetch" href="/assets/js/79.e57da09f.js"><link rel="prefetch" href="/assets/js/8.1a5806a3.js"><link rel="prefetch" href="/assets/js/80.0a92fb8d.js"><link rel="prefetch" href="/assets/js/81.81388add.js"><link rel="prefetch" href="/assets/js/82.9a93f3cc.js"><link rel="prefetch" href="/assets/js/83.5d1c8c08.js"><link rel="prefetch" href="/assets/js/85.a902abf2.js"><link rel="prefetch" href="/assets/js/86.3c4137ab.js"><link rel="prefetch" href="/assets/js/87.56a23aaa.js"><link rel="prefetch" href="/assets/js/88.e83370ce.js"><link rel="prefetch" href="/assets/js/89.b0412ceb.js"><link rel="prefetch" href="/assets/js/9.4060c407.js"><link rel="prefetch" href="/assets/js/90.648c1a43.js"><link rel="prefetch" href="/assets/js/91.ed17a853.js"><link rel="prefetch" href="/assets/js/92.1f7f271e.js"><link rel="prefetch" href="/assets/js/93.cb0e3132.js"><link rel="prefetch" href="/assets/js/94.aa3aaf4d.js"><link rel="prefetch" href="/assets/js/95.659a6710.js"><link rel="prefetch" href="/assets/js/96.ff14d3ef.js"><link rel="prefetch" href="/assets/js/97.e3695f02.js"><link rel="prefetch" href="/assets/js/98.56f35a3c.js"><link rel="prefetch" href="/assets/js/99.ddd7e981.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5dc1cf24.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/zh/" class="home-link router-link-active"><!----> <span class="site-name">后土维基</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/zh/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文档" class="dropdown-title"><span class="title">文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="文档" class="mobile-dropdown-title"><span class="title">文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/zh/sitio/" class="nav-link">
  Hexo-theme-sitio
</a></li></ul></div></div><div class="nav-item"><a href="/zh/basics/" class="nav-link">
  笔记
</a></div><div class="nav-item"><a href="https://github.com/Aftersoil/Aftersoil-wiki" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Select language" class="dropdown-title"><span class="title">选择语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="Select language" class="mobile-dropdown-title"><span class="title">选择语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/javaScriptTop/" class="nav-link">
  English
</a></li><li class="dropdown-item"><!----> <a href="/zh/frontend/javaScriptTop/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
   简体中文
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/zh/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文档" class="dropdown-title"><span class="title">文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="文档" class="mobile-dropdown-title"><span class="title">文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/zh/sitio/" class="nav-link">
  Hexo-theme-sitio
</a></li></ul></div></div><div class="nav-item"><a href="/zh/basics/" class="nav-link">
  笔记
</a></div><div class="nav-item"><a href="https://github.com/Aftersoil/Aftersoil-wiki" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Select language" class="dropdown-title"><span class="title">选择语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="Select language" class="mobile-dropdown-title"><span class="title">选择语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/javaScriptTop/" class="nav-link">
  English
</a></li><li class="dropdown-item"><!----> <a href="/zh/frontend/javaScriptTop/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
   简体中文
</a></li></ul></div></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js-正则表达式"><a href="#js-正则表达式" class="header-anchor">#</a> JS 正则表达式</h1> <p>概述  正则表达式 专门描述字符串中字符串出现规则的表达式</p> <h2 id="正则表达式用于"><a href="#正则表达式用于" class="header-anchor">#</a> 正则表达式用于:</h2> <ol><li>验证字符串格式</li> <li>查找敏感词</li></ol> <h2 id="定义正则表达式"><a href="#定义正则表达式" class="header-anchor">#</a> 定义正则表达式</h2> <ul><li><h3 id="使用字符集简写"><a href="#使用字符集简写" class="header-anchor">#</a> 使用字符集简写</h3> <ul><li>多选一规则匹配
[备选方案]
[卧我]
[0-9] 区间内选一</li></ul></li> <li><h2 id="其他简写"><a href="#其他简写" class="header-anchor">#</a> 其他简写</h2> <ol><li>匹配一位小写音文字母 [a-z] 共26个</li> <li>匹配一位大写音文字母 [A-Z] 共26个</li> <li>要匹配一位字母 [A-Za-z] 共52个</li> <li>要匹配一位字母或数字 [0-9A-Za-z] 共62个</li></ol> <h2 id="_5-要匹配一位汉字-u4e00-u9fa5-19968-40869-共20902个"><a href="#_5-要匹配一位汉字-u4e00-u9fa5-19968-40869-共20902个" class="header-anchor">#</a> 5. 要匹配一位汉字 [\u4e00-\u9fa5] 19968~40869 共20902个</h2> <div class="language- extra-class"><pre><code>      例子:
      利用字符集简写定义车牌号规则
      1. 第一位  1位汉字
      2. 第二位  1位大写字母
      3. 第三位   .
      4. 后五位  每一位 都是一位大写字母或数字 
  
      答案:[\u4e00-\u9fa5][A-Z].[0-9A-Z][0-9A-Z][0-9A-Z][0-9A-Z][0-9A-Z] 
</code></pre></div></li> <li><h3 id="预定义字符集"><a href="#预定义字符集" class="header-anchor">#</a> 预定义字符集</h3> <div class="language- extra-class"><pre><code>- 要匹配一位数字: \d 等效于[0-9];
- 要匹配一位字母,数字或:\w 等效于 [0-9A-Za-z];
- 要匹配一位空字符 \s 可匹配 空格,制表符Tab 等 空白
- 要匹配所有(通配符)  .
</code></pre></div></li></ul> <p>手机号规则可进一步简写:
1[3-8]\d\d\d\d\d\d\d\d\d</p> <ul><li><h1 id="数量词"><a href="#数量词" class="header-anchor">#</a> 数量词</h1> <ul><li>手机号实例   \d{9} 等同于 \d * 9 次
例 : [3-9]\d{9}</li> <li>车牌号简写
例 : [\u4e00-\u9fa5][A-Z].[A-Z0-9]{5}</li></ul></li> <li><h3 id="数量词-包含两大类"><a href="#数量词-包含两大类" class="header-anchor">#</a> 数量词 包含两大类</h3> <ol><li><p>有明确数量边界的数量词</p> <div class="language- extra-class"><pre><code>   - 字符集{n} 表示字符集必须重复n次 不能多也不能少
   - 字符集{n,m} 表示字符集至少重复n次 最多重复 m 次
     比如： \d{4,6}
   - 字符集{n,}表示字符集匹配内容至少 重复n 次 多了不限
</code></pre></div></li> <li><p>没有明确数量边界的数量词</p> <div class="language- extra-class"><pre><code>   - \* 可有可无 多了不限
   - ？ 可有可无 最多一次
   - \+  至少一次 多了不限
   - \s*   \s+  \s?
</code></pre></div></li></ol></li></ul> <ul><li><p>例子:
匹配手机短信中验证码  连续4为 到 6位的手机号</p> <p>正则表达式 大部分情况采用 贪婪模式进行匹配
尽量匹配最长的关键词</p></li></ul> <ul><li><h2 id="选择和分组"><a href="#选择和分组" class="header-anchor">#</a> 选择和分组</h2> <ol><li><p>选择 指多个子规则选择其一进行匹配</p> <div class="language- extra-class"><pre><code> 子选择1 | 子选择2
</code></pre></div></li> <li><p>分组 多个子规则分为一组 再和分组外的规则匹配</p></li></ol> <div class="language- extra-class"><pre><code>其他规则(多个子规则)

例: ([我卧]|wo)\s*([草艹槽]|cao)
</code></pre></div><ol start="2"><li><p>定义完整手机号规则</p> <div class="language- extra-class"><pre><code> - +86 或 0086
 - (\+86|0086)
 - 至少一个空字符:\s+ 
 - 之前所有可有可无 至少一次()?
 - 1 
 - 3~8 任选其一
 - 0-8
   \\+ 转义字符
</code></pre></div><p>答案: ((+86|0086)\s+)?1[3-8]/d{9}</p></li> <li><p>定义完整身份证号规则</p> <div class="language- extra-class"><pre><code> - 15位数字 \d{15}
 - 2位数字 \d\d
 - 最后一位:  1位数字 或 X[0-9x]
 - 最后三位 可有可无 虽多一次

 定义完整身份证正则
 \d{15}(\d\d[0-9x])?
</code></pre></div></li></ol></li></ul> <p>作业需求:  匹配 &quot;微信&quot;,&quot;weixin&quot;,&quot;w x&quot; 等情况 并防止 中间加空格</p> <ul><li><h2 id="指定匹配位置"><a href="#指定匹配位置" class="header-anchor">#</a> 指定匹配位置</h2> <ul><li><p>使用情况  如果只希望匹配特殊位置上的关键词时 就可以使用特殊符号 表示特殊位置</p> <div class="language- extra-class"><pre><code> 1. ^ 表示字符串开头  
 2. $ 表示字符串结尾
 3. \b 表示单词边界,可匹配: 空格 标点符号 字符串开头和结尾等 可将一个单词与其他单词分割开的符号
</code></pre></div></li></ul> <p>找到开头和结尾空格</p> <p>例如 ^\s+$ //错误写法</p> <div class="language- extra-class"><pre><code>      正确写法     
     ^\s+|\s+$
</code></pre></div><ul><li><p>常见面试题</p> <div class="language- extra-class"><pre><code>  - 找到每个单词的首字母
  - ———— 前边紧挨着的单词边界字母
  ^\b[A-Za-z]
</code></pre></div></li></ul></li></ul> <p>作业需求</p> <p>使用正则匹配电子邮件: ___ 记住</p> <ul><li><h2 id="string-的正则函数"><a href="#string-的正则函数" class="header-anchor">#</a> String 的正则函数</h2> <ul><li><p>查找敏感词  4种情况</p> <ul><li><p>1 查找一个固定的敏感词位置 i;</p> <div class="language- extra-class"><pre><code>var i=str.indexOf(&quot;敏感词&quot;,fromi)
</code></pre></div><p>在str中 从 fromi 开始 向后查找下一个“敏感词”的下标位置 i</p> <p>找到 返回敏感词第一个字的下标位置
没找到返回 -1</p> <p>问题: indexOf 只能查找固定的敏感词 而且不支持正则！</p></li> <li><p>2  用正则表达式 模糊查找多种敏感词</p> <div class="language- extra-class"><pre><code> -  var i = str.search(/正则/i)
   -  i 不区分大小写
   - 原理和用法几乎相同
   - 差别
       - 1 用灵活的正则表达式 代替了写死的敏感词 
       - 2 只有一个参数 不能指定开始的位置 永远只能从头开始找  
</code></pre></div></li></ul></li></ul></li> <li><h2 id="扩展-test"><a href="#扩展-test" class="header-anchor">#</a> 扩展 .test()</h2> <ul><li><p>test() 方法是正则表达式的一个方法，用于检测一个字符串是否匹配某个模式</p></li> <li><p>如果是则返回 true，否则就返回 false</p></li> <li><p>regexp.test(str)</p> <div class="language- extra-class"><pre><code>手机号验证：!/^[1][3,4,5,7,8][0-9]{9}$/.test(this.phone)
</code></pre></div></li></ul></li></ul> <hr> <h1 id="string-正则函数"><a href="#string-正则函数" class="header-anchor">#</a> String 正则函数</h1> <h2 id="查找敏感词"><a href="#查找敏感词" class="header-anchor">#</a> 查找敏感词</h2> <p>4种</p> <ol><li><p>固定敏感词出现的位置</p> <div class="language- extra-class"><pre><code>     var i = str.indexOf(&quot;敏感词&quot;,fromi);
   没有给定值 从0开始找
   没找到返回-1
   问题： 如果换成同音字或拼音,就找不到了
</code></pre></div></li> <li><p>用正则表达式模糊查找一个敏感词的位置</p> <div class="language- extra-class"><pre><code>       var i=str.search(/正则表达式/i) 
   问题：只能返回敏感词的位置 不能返回敏感词具体的内容
</code></pre></div></li> <li><p>获取敏感词内容 2种</p> <div class="language- extra-class"><pre><code>   - var arr = str.match(/正则/i)
   - 在str中 查找一个符合正则要求的敏感词的内容和位置
   - 返回值 返回一个数组 
   - 没找到 返回null 
   - 如果想获得本次查找的内容 arr[0]  
   - 如果想获得本次查找的位置  arr
 
   [&quot;index&quot;] 必须添加 &quot;&quot;
 
   正则表达式只能匹配一个敏感词 -g 找出所有
 
   str.match(//ig);
     
     问题:  如果match+g 只能返回敏感词内容 无法返回敏感词位置 
     如果只关心 敏感词内容  就使用 match+g 
</code></pre></div></li></ol> <h2 id="强调"><a href="#强调" class="header-anchor">#</a> 强调</h2> <ul><li><h4 id="如果一个函数有可能返回null-则使用前必须先验证-是不是null-才能使用-因为null之后-什么都不可以加-null-报错-null-报错"><a href="#如果一个函数有可能返回null-则使用前必须先验证-是不是null-才能使用-因为null之后-什么都不可以加-null-报错-null-报错" class="header-anchor">#</a> 如果一个函数有可能返回null! 则使用前必须先验证 是不是null 才能使用  因为null之后 什么都不可以加 null 报错 null. 报错</h4></li> <li>${arr!=null?arr.length:0}</li></ul> <h1 id="js-底层数组都是关联数组"><a href="#js-底层数组都是关联数组" class="header-anchor">#</a> Js 底层数组都是关联数组  &quot;&quot; : &quot;&quot;</h1> <h3 id="arr-length-arr-length-数字下标不能简写-与小数点冲突"><a href="#arr-length-arr-length-数字下标不能简写-与小数点冲突" class="header-anchor">#</a> arr.length arr[&quot;length&quot;]  数字下标不能简写!  与小数点冲突</h3> <ol start="4"><li><p>既查找每个关键词的内容 又查找关键词的位置</p> <div class="language- extra-class"><pre><code>   - RegExp对象 exec() 函数
</code></pre></div></li></ol> <h1 id="替换敏感词"><a href="#替换敏感词" class="header-anchor">#</a> 替换敏感词</h1> <ol><li><p>简单替换 将所有敏感词替换统一新词</p> <div class="language- extra-class"><pre><code>  str = str.replace(/正则/ig,&quot;新词&quot;)

   坑： 替换后 不报错也替换不成功

   因为 字符串都是不可变类型 ！
        无法对原字符串直接进行修改
        所有字符串函数 都只能返回修改后的字符串 而保持原字符串不变
   解决 想要获得新值 必须用=接住新值保存到变量中
</code></pre></div></li> <li><p>高级替换 根据每次找到的敏感词不同 动态选择不同的新词替换！</p> <div class="language- extra-class"><pre><code>    //replace 会自动在每个找到的关键词上调用一次这个
  
   //回调函数 找到几个词 就反复调用几次 每次调用时 会
  
   //自动将本次找到的关键词传给函数keyword
</code></pre></div></li></ol> <div class="language- extra-class"><pre><code>2个要求
                
      function(keyword){
         1 必须有一个参数接住本次找到的一个关键词
      
         2 必须返回处理后的新词
            return keyword.toLocaleUpperCase();
          }
          
        所有形参可自己定义参数名
        补 回调函数 callback 我们自己定义的 但不是我们自己调用去执行 而是交给其他对象去执行
</code></pre></div><p>衍生：删除敏感词 其实就是将敏感词替换为&quot;&quot;</p> <div class="language- extra-class"><pre><code>    function trim(str){
        return str.replace(/^\s+|\s+$/,&quot;&quot;);
        }
</code></pre></div><ol start="3"><li>切割敏感词</li></ol> <p>什么是 根据指定的切割符 切割成多段字符串</p> <div class="language- extra-class"><pre><code>2种: 

    1. 简单切割  切割符是固定的
       - var arr = str.split(&quot;切割符&quot;);
       * 将字符串 str 
    
    2. 复杂切割 : 切割符是变化的 但是有规律的。 
    
       - var arr=str.split(/正则/)
    
       - 例如按照空格进行分割
    
     - 衍深操作：打撒字符串为字符数组
</code></pre></div><ul><li>总结：
<ul><li><p>查找敏感词</p> <ul><li><ol><li><p>查找一个固定的敏感词</p> <div class="language- extra-class"><pre><code>str.indexOf(&quot;敏感词&quot;,fromi);
</code></pre></div></li></ol></li> <li><ol start="2"><li><p>使用正则模糊查找一个敏感词位置</p> <div class="language- extra-class"><pre><code>str.search(/正则/i)
</code></pre></div></li></ol></li> <li></li> <li><ol start="3"><li>用正则查找一个敏感词的内容</li></ol></li></ul></li> <li><ol><li><p>只查找一个敏感词的位置 和内容</p> <div class="language- extra-class"><pre><code>          var arr = str.match(/正则/i)
</code></pre></div></li></ol></li> <li><ol start="2"><li><p>查找全部敏感词内容 但无法获取位置</p> <div class="language- extra-class"><pre><code> str.match(//ig);
</code></pre></div><ul><li><ol start="4"><li>既查找每个敏感词内容 又查找每个敏感词的位置</li></ol></li></ul></li></ol> <ul><li>替换敏感词
<ul><li>删除</li></ul></li> <li>切割
<ul><li>打撒字符串为字符数组</li></ul></li></ul></li></ul></li></ul> <h2 id="regexp对象"><a href="#regexp对象" class="header-anchor">#</a> RegExp对象:</h2> <ul><li><p>专门保存一条正则表达式 并提供正则执行查找和验证方法的对象
何时:</p> <ol><li><p>验证时</p></li> <li><p>高级查找时
如何:</p></li> <li><p>创建对象:2种</p> <ol><li><p>简化版创建</p> <div class="language- extra-class"><pre><code> var reg = /\b[a-z]ig;
</code></pre></div><p>何时 如果正则表达式固定不变的w
问题 不支持动态生成正则表达式
因为://之间是正则表达式的地盘 js不认识</p></li> <li><p>用new创建</p> <div class="language- extra-class"><pre><code> var reg = RegExp(&quot;\b[a-z]&quot;,&quot;ig&quot;);
</code></pre></div><p>何时  如果正则表达式需要根据变量数组内容 动态生成！</p> <p>因为：这种方法用js认识的&quot;&quot;代替了// 而在js中 有很多办法 灵活的拼接想要的字符串</p></li></ol></li> <li><p>RegExp</p> <ol><li><p>验证格式：</p> <p>var bool = reg.test(str);</p></li></ol></li></ol> <p>用reg规则 检测str 是否符合规则要求
返回值：true/false</p> <p>坑: test 默认只要在str 中找到部分 和 reg 匹配的 就返回true ！ 而不要求 从头到尾匹配</p> <h2 id="解决-凡是验证-都要求从头到尾必须完整匹配"><a href="#解决-凡是验证-都要求从头到尾必须完整匹配" class="header-anchor">#</a> 解决：凡是验证 都要求从头到尾必须完整匹配</h2> <div class="language- extra-class"><pre><code>   前加 ^ 结尾加 $ 
</code></pre></div><p>意味从头到尾</p> <div class="language- extra-class"><pre><code>   只要使用test 必须使用 前后+^$
</code></pre></div></li></ul> <h1 id="regexp"><a href="#regexp" class="header-anchor">#</a> RegExp :</h1> <ol><li><p>验正字符串格式 bool= reg.test();</p></li> <li><p>既查找内容 有查找关键词的位置</p> <p>var arr = reg.exec(str);</p> <p>在str 中查找下一个关键词的位置和内容</p> <p>返回值 和match 不加 g 的时候是相同的
知道到 arr[0:关键词的内容,index: 位置]
如果没有找到返回null</p></li></ol> <h2 id="function"><a href="#function" class="header-anchor">#</a> Function</h2> <h2 id="什么是"><a href="#什么是" class="header-anchor">#</a> 什么是：</h2> <p>用途 保存一段可重用的代码段的程序结构 再起一个名字</p> <p>本质 内存中保存一段代码段的存储空间--</p> <h2 id="为什么"><a href="#为什么" class="header-anchor">#</a> 为什么：</h2> <div class="language- extra-class"><pre><code>代码重用
何时 只要一段代码 可能被反复使用 都要定义在一个函数内 再起个名字 今后 用函数名等于用代码段
</code></pre></div><p>如何</p> <p>创建函数 3种</p> <div class="language- extra-class"><pre><code>       1. function 函数名 (形参列表){
          函数体
          return 返回值
       }
</code></pre></div><p>形参是什么</p> <div class="language- extra-class"><pre><code>          专门接受 从函数外部传入函数内部数据的变量
</code></pre></div><p>为什么</p> <div class="language- extra-class"><pre><code>          有些函数执行时  需要动态获得必须的数据 才能正常执行
</code></pre></div><p>何时</p> <div class="language- extra-class"><pre><code>          只要一个函数 必须某些数据 才能正确执行
</code></pre></div><p>返回值</p> <div class="language- extra-class"><pre><code>      什么是  一个函数的执行结果
      
      为什么 外部调用者可能需要获得函数执行结果
      
      何时   只要外部调用者 需要获的函数的执行结果
</code></pre></div><p>笔试问题</p> <div class="language- extra-class"><pre><code>问题  会被声明提前
</code></pre></div><p>什么是</p> <p>在程序执行前！程序会先将所有var 声明的变量和function声明的函数 提前到当前作用域的顶部集中创建 而(赋值=)留在原地</p> <p>所以声明提前是js广受诟病的缺陷</p> <p>打乱了程序正常执行的顺序</p> <ol start="3"><li><p>new 来创建</p> <div class="language- extra-class"><pre><code> var fun = new Function(&quot;形参1&quot;,&quot;形参2&quot;)
</code></pre></div></li></ol> <p>2 赋值方式创建：</p> <div class="language- extra-class"><pre><code>      var 函数名 = function(形参列表){
          函数体
      }

说明: 赋值方式创建的函数 和声明方式 创建的函数在使用时 都一样
只不过 在程序开始执行前 赋值方式可避免函数被声明提前 保持了程序原有的执行顺序

揭示: js中其实函数也是一个普通的对象而已,函数名仅仅是一个普通的变量 函数名变量通过对象地址引用着函数对象,每次调用函数名时 通过地址 找到函数对象 再执行其中内容

变量 : 内存中存储一个数据的存储空间 在起一个名字
</code></pre></div><p>强调 如果一个函数 只是定义 没有调用 该函数体是不会执行</p> <p>global[&quot;a&quot;];  底层  关联数组</p> <h3 id="重载-overload"><a href="#重载-overload" class="header-anchor">#</a> 重载(overload)</h3> <h2 id="什么是-2"><a href="#什么是-2" class="header-anchor">#</a> 什么是:</h2> <div class="language- extra-class"><pre><code>  多个同名函数 不同形参列表 在调用时根据传入实参列表的不同 动态选择函数执行 
</code></pre></div><h2 id="为什么-2"><a href="#为什么-2" class="header-anchor">#</a> 为什么</h2> <div class="language- extra-class"><pre><code>  减少函数个数 减轻调用者的负担
</code></pre></div><h2 id="何时"><a href="#何时" class="header-anchor">#</a> 何时</h2> <div class="language- extra-class"><pre><code>  只要一件事 可能根据传入参数的不同  执行不同的逻辑 都要使用重载！
</code></pre></div><h2 id="如何"><a href="#如何" class="header-anchor">#</a> 如何:</h2> <div class="language- extra-class"><pre><code>  问题Js不支持标准的重载写法 因为js不允许多个同名函数的存在！
</code></pre></div><h2 id="解决"><a href="#解决" class="header-anchor">#</a> 解决:</h2> <div class="language- extra-class"><pre><code>    js中借助于arguments 对象实现重载
</code></pre></div><h2 id="什么是-3"><a href="#什么是-3" class="header-anchor">#</a> 什么是:</h2> <div class="language- extra-class"><pre><code>    每个函数内自带的 专门接收所有传入函数的实参值列表的数组对象。

函数内自带对象 不用创建可直接拿来使用 接收所有传入函数的实参值 即使没有定义形参变量 或形参变量个数少于传入实参值个数 都没关系

arguments 可接住所有传入函数的实参值 这就是为什么js 中的函数 定义了几个形参和调用了几个实参 毫无关系
</code></pre></div><h1 id="类数组对象"><a href="#类数组对象" class="header-anchor">#</a> 类数组对象:</h1> <div class="language- extra-class"><pre><code>长得像数组的对象
  像数组 1 小标 2 length
  不是数组 是对象 不是数组家孩子
</code></pre></div><h2 id="何时-2"><a href="#何时-2" class="header-anchor">#</a> 何时:</h2> <div class="language- extra-class"><pre><code>  只要js中接收不确定个数的参数值 都用arguments.
</code></pre></div><h2 id="如何-2"><a href="#如何-2" class="header-anchor">#</a> 如何:</h2> <div class="language- extra-class"><pre><code>  1 无论传入多少个参数 都只定义一个函数 
  2 在函数内直接访问 arguments 根据 arguments 不同 动态选择不同的逻辑执行任务。
</code></pre></div><p>如果只是部分参数不确定 而且参数赋值给参数时 又要求对应关系怎么办？</p> <div class="language- extra-class"><pre><code>    cook(,,&quot;面&quot;)
</code></pre></div><p>答: 以上传参方式 会报语法错误！因为实参列表不允许出现空值</p> <h3 id="当遇到多个参数不确定有没有-又要要求对应关系时-只能使用对象语法解决"><a href="#当遇到多个参数不确定有没有-又要要求对应关系时-只能使用对象语法解决" class="header-anchor">#</a> 当遇到多个参数不确定有没有 又要要求对应关系时 只能使用对象语法解决</h3> <p>2 步</p> <p>1 定义函数时:</p> <div class="language- extra-class"><pre><code>      function 函数(形参列表变量){
        // 先判断 obj 对象包含那些属性 不包含那些属性 缺少的属性用默认值代替
        // 函数执行过程中 都从对象里,取实参值使用！
      } 
      
      但是, 我们规定 在将来调用时 实参值都要放在一个对象中传入
</code></pre></div><p>2  调用函数时:</p> <div class="language- extra-class"><pre><code>            函数名({属性1:实参值1，,属性2:实参值2...});
</code></pre></div><h2 id="优点-任意参数都可以缺少-都不会报错"><a href="#优点-任意参数都可以缺少-都不会报错" class="header-anchor">#</a> 优点: 任意参数都可以缺少 都不会报错</h2> <p>1 Test
任意参数求和</p> <h2 id="匿名函数"><a href="#匿名函数" class="header-anchor">#</a> 匿名函数</h2> <p>什么是：</p> <div class="language- extra-class"><pre><code>    定义函数时 不被任何变量所引用的函数  
      (function(){}());
</code></pre></div><p>为什么： 1 为了节约内存 2 划分临时作用域！</p> <p>何时：</p> <div class="language- extra-class"><pre><code>    1. 如果一个函数只执行一次 
    2. 划分临时作用域！
</code></pre></div><p>如何:</p> <div class="language- extra-class"><pre><code>    1. 回调函数: 今后大多为匿名函数
    2. 匿名函数自调
    1. 为什么  全局变量 极易被污染！ 今后禁止使用全局变量 !
</code></pre></div><p>匿名函数自调 定义函数后 立即调用函数 调用后立即释放！</p> <p>问题 全局变量极易被污染！又不会自动释放 所以 今后禁止使用全局变量</p> <div class="language- extra-class"><pre><code>解决 今后js 代码 都要包裹在匿名函数自调用中 
好处 绝对不会产生全局变量 节约内存又不影响功能执行
</code></pre></div><h1 id="作用域和作用域链"><a href="#作用域和作用域链" class="header-anchor">#</a> 作用域和作用域链</h1> <h2 id="作用域-scope"><a href="#作用域-scope" class="header-anchor">#</a> 作用域(scope):</h2> <p>什么是</p> <div class="language- extra-class"><pre><code>用途: 作用域就是一个变量的可用范围
本质：作用域是保存变量的一个对象
为什么： 为了避免不同范围得变量互相干扰!
包括 JS中只包括2级作用域
</code></pre></div><p>​<br>
​        1. 全局作用域：
​<br>
1. 保存任何地方都可以访问到的变量区域
2. 全局中保存的变量称为全局变量
3. 全局变量优点 共用 可反复使用
4. 缺点 易被污染 浪费内存</p> <p>​<br>
​        2. 函数作用域
​                1. 保存在函数内才可以使用的变量区域
​                2. 函数作用域中保存的变量是局部变量
​                3. 局部变量优点 仅函数内可用 不会污染全局且用完就释放  不占用内存
​                4. 缺点 无法重用！</p> <h2 id="程序和函数的执行过程"><a href="#程序和函数的执行过程" class="header-anchor">#</a> 程序和函数的执行过程：</h2> <p>1.当程序执行时 先创建全局作用域对象window</p> <p>在window中 先保存所有的全局变量 和全局 函数</p> <ol start="2"><li><p>当定义函数时 每个函数其实都有一个好友列表 暂时包含两项 离自己最近的一项是暂时是空的  距离自己远一些的一项保存着指向window 对象的地址</p></li> <li><p>&quot;好友列表&quot;作用是 将来调用函数时,万一缺变量,可按照好友列表的顺序 去朋友中寻找</p></li></ol> <p>当调用函数时 会临时创建这次调用函数的函数作用域对象 并在函数作用域对象中添加函数的局部变量 并将函数作用域对象的引用 假如函数的好友列表中最近的一项保存！说明函数和临时创建的函数作用域对象 关系最好！ 缺变量 先找临时创建的函数作用域对象  如果函数作用域对象没有 才被迫找window要</p> <div class="language- extra-class"><pre><code>当函数调用后 临时创建的函数作用域对象被释放 函数作用域对象中的变量同时释放 —————— 这就是为什么局部变量不可重用 的原因！！！
</code></pre></div><h2 id="作用域链-scopes"><a href="#作用域链-scopes" class="header-anchor">#</a> 作用域链(scopes)</h2> <p>什么是:</p> <div class="language- extra-class"><pre><code>一个函数可用的所有作用域对象的集合。
</code></pre></div><p>普通函数的作用链 在调用时是两个成员</p> <div class="language- extra-class"><pre><code>    1. 距离自己最近的是临时创建的函数作用域对象
    2.  离自己稍微远一些的是全局作用域对象 window
</code></pre></div><p>一个函数的作用域链</p> <div class="language- extra-class"><pre><code>         1.  保存着这个函数可用的所有变量
         2.  控制这变量的使用顺序
             
             先局部 后全局
</code></pre></div><h1 id="闭包-closure"><a href="#闭包-closure" class="header-anchor">#</a> 闭包(closure)</h1> <h2 id="什么是闭包"><a href="#什么是闭包" class="header-anchor">#</a> 什么是闭包：</h2> <div class="language- extra-class"><pre><code>用途: 

  既重用一个变量 有保护这个变量不被污染的一种编程方法

本质: 
    
    外层函数的作用域对象 被内层函数对象引用着 无法释放  这个外层函数的作用域就是闭包对象

为什么: 

    全局变量和局部变量的优缺点
    全局变量: 优点 可重用 缺点 极易被污染！;
    局部变量：优点  不会被污染 缺点:不可重用！;
</code></pre></div><p>何时：</p> <div class="language- extra-class"><pre><code>  今后 只要为一个函数保存一个专属的 可重用的 还不会被外部污染的变量
</code></pre></div><p>如何：4步</p> <div class="language- extra-class"><pre><code>        1. 外层函数包裹要保护的变量和内层函数
           内层函数一定要使用了外层函数的局部变量
        2. 外层函数将内层函数抛到外部
        3. 调用者调用外层函数 获得返回的内层函数对象 保存在变量中。 并反复使用。
        4. 外层定义一个变量接收return出的参数
</code></pre></div><p>闭包是如何形成的</p> <div class="language- extra-class"><pre><code>  外层函数作用域对象,被内层函数对象引用着无法释放
</code></pre></div><p>闭包的缺点</p> <div class="language- extra-class"><pre><code>1. 比普通函数占用更多内存
2. 多占用父母函数作用域对象
3. 闭包不会自动释放 可能造成内存泄漏
</code></pre></div><p>解决: 使用完闭包后 如果不在使用了 要手动释放闭包
pay = null</p> <p>定义一个取号机函数 getNum() 可反复输出一个递增的不重复的数字</p> <p>var getNum()
getNum();//1
getNum();//2
//试图用同名变量篡改序号为0
xxx=0;
getNum();//3</p> <p>function fun(){
var n = 999
nAdd = function(){n++}
return function(){
console.log(n)
}
}
var getN = fun();
getN();//?
nAdd();
getN();//?</p> <hr> <h1 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h1> <p>什么是对象:</p> <div class="language- extra-class"><pre><code>用途: 对象是描述现实中一个具体事物的属性和功能的程序结构

本质： 程序中集中存储一个事物的属性和功能的一块存储空间 再起一个名字
</code></pre></div><p>为什么：</p> <div class="language- extra-class"><pre><code>  便于大量数据的维护和使用
</code></pre></div><p>什么是面向对象编程：</p> <div class="language- extra-class"><pre><code>  程序都是先将数据封装在对象中 然后再按需使用对象中的成员。 这样的编程方式 就是面向的对象编程
</code></pre></div><p>何时:</p> <div class="language- extra-class"><pre><code>  今后所有程序都是用面向对象方式实现的
</code></pre></div><p>如何：
面向对象三步/三大特点: 封装 继承 多态</p> <h1 id="封装-继承-多态"><a href="#封装-继承-多态" class="header-anchor">#</a> 封装 继承 多态</h1> <h2 id="封装"><a href="#封装" class="header-anchor">#</a> 封装：</h2> <p>什么是：</p> <div class="language- extra-class"><pre><code>  创建一个对象 集中保存一个事物的属性和功能
</code></pre></div><p>何时：</p> <div class="language- extra-class"><pre><code>  - 只要使用面向对象方式编程 都要先将数据和功能封装在对象中 然后再按需使用。
</code></pre></div><p>如何3种：</p> <div class="language- extra-class"><pre><code>      1.用{} 创建一个对象
            
                  var 对象名={
                      属性名:值,
                      ....
                      方法:function(){
                        
                      }
                  }
</code></pre></div><p>如何访问</p> <div class="language- extra-class"><pre><code>      对象名.属性名
      对象名.方法(){}   
</code></pre></div><p>问题：</p> <div class="language- extra-class"><pre><code>  在对象自己的方法 直接使用属性名却无法访问到自己的属性 报错 属性名未定义
</code></pre></div><p>原因</p> <div class="language- extra-class"><pre><code>  所有不带.的变量,默认只能在作用域链中(临时函数作用域和我window)查找。 但是对象中{}又不是作用域 所以对象是不包含在作用域链中的 所以直接使用属性,无法找到藏在对象内的属性的。 不好的解决方法：在属性名前加对象. ,勾引着引擎进入对象中查找属性。
</code></pre></div><p>问题：</p> <div class="language- extra-class"><pre><code>    紧耦合 如果外部修改 内部被迫跟着修改
</code></pre></div><p>解决:
松耦合 外部改变 内部d代码不用改变 也能自动适应</p> <h1 id="this-属性名"><a href="#this-属性名" class="header-anchor">#</a> ———— this.属性名</h1> <h2 id="什么是this"><a href="#什么是this" class="header-anchor">#</a> 什么是this:</h2> <div class="language- extra-class"><pre><code>  在调用函数时 临时指向正在调用函数的.前对象的关键词

  总结 只要是自己的方法 想访问自己的属性就使用this
</code></pre></div><p>错误：</p> <div class="language- extra-class"><pre><code>函数定义在哪个对象中 this就指向哪个对象 
</code></pre></div><p>正确：
this与函数定义在哪无关！只与函数调用这一瞬间.前对象有关</p> <div class="language- extra-class"><pre><code>    2.   用new创建：2步
            1.   先创建空对象 var obj = new Object();
            2.  强行向空对象中添加新属性  
                1.  obj.属性 = 值
                2.  obj.方法 = function(){...}
            揭示： 所有js对象底层 都是关联数组。
</code></pre></div><h1 id="对象-vs-关联数组"><a href="#对象-vs-关联数组" class="header-anchor">#</a> 对象 VS 关联数组</h1> <h2 id="相同-4-个"><a href="#相同-4-个" class="header-anchor">#</a> 相同 4 个</h2> <div class="language- extra-class"><pre><code>            1. 都可以用[&quot;成员名&quot;]或.成员名两种方式 访问自己的成员。 .成员名 其实就是[&quot;成员名&quot;] 简写 也就是说 .成员名 到底层会被自动翻译成[&quot;成员名&quot;]
            
            坑 如果成员名来自于一个变量！ 则不能用&quot;.变量&quot;方式访问成员。因为.&quot;变量&quot; 会被翻译为[&quot;变量&quot;], 出错了 因为变量不可以放在&quot;&quot;里！
            解决: 今后只要成员名不是写死的，而是来自于一个变量 只能用[变量], 不带引号的方式访问

            2. 都可以被for in循环遍历每个成员
            
            3.  随时可以给数组或对象在任何位置添加新成员,而不会报错！ 而自动创建该成员
              所以 如果想给一个已创建玩得对象 添加新属性 只有一个野蛮的办法 强行赋值！

            4.  访问数组或对象中不存在的位置 不会报错 而是返回undefined！

              不同 类型
                    关联数组: 是数组家的孩子
                    对象 是object 孩子
</code></pre></div><p>问题:</p> <div class="language- extra-class"><pre><code>  只能创建一个对象 如果反复创建 多个相同结构的对象时。
  代码很冗余 不便于维护。
</code></pre></div><p>解决:</p> <div class="language- extra-class"><pre><code>用构造函数：
什么是： 专门描述一类对象统一结构的函数
为什么:  为了重用对象的结构定义 
何时： 只要程序中需要反复创建 同一类型的多个对象时。
</code></pre></div><h1 id="构造函数"><a href="#构造函数" class="header-anchor">#</a> 构造函数</h1> <div class="language- extra-class"><pre><code>  如何: 2步
    1. 定义构造函数来描述一类对象同意结构
        function 类型名(形参1){
          this.属性名 = 形参1;
          this.属性名...形参1;
          this.方法=function(){}
        }
    2. 调用构造函数按照统一结构创建对象  
        var obj = new 类型名(属性值1,);   
        new 的 原理：4件事;
            1. 新建一个空对象
            2. ？
            3. 用new调用构造函数 将构造函数中的this 都吸引到new上!
              然后通过强行赋 
      问题：构造函数虽然实现了代码重用,但是浪费了内存！
</code></pre></div><h1 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h1> <p>什么是: 爹的成员 孩子无需重复创建,可直接使用</p> <p>为什么: 代码重用, 节约内存</p> <p>何时：</p> <div class="language- extra-class"><pre><code>    只要多个孩子都需要共用的成员,都通过继承使用！
</code></pre></div><p>如何：
不用自己设置继承关系！其实js中已经帮我们设置好了继承关系</p> <div class="language- extra-class"><pre><code>  我们直接使用即可！
           
           1. js实现继承, 都是通过继承原型对象来实现的
              原型对象：专门集中保存一类对象的共有成员的父对象。

              原型对象是在定义构造函数时,附赠的。只不过暂时是空的
              如何找到原型对象: 每个构造函数都有一个prototype 指向自己附赠的这个原型对象
              其实 原型对象中 也有一个constructor属性 指回构造函数

              子对象如何继承父对象:
              new 的 第2步：让子对象的__proto__属性指向妈妈的原型对象 凡是从__proto__属性值指出的关系,都叫继承关系。
        
        结果： 原型对象中的成员 子对象无需创建 可直接使用！
</code></pre></div><p>如何向原型对象中添加共有成员:</p> <div class="language- extra-class"><pre><code>    妈妈.prototype.成员名=值
    比如 向所有学生的共同的爸爸 里强行添加一个公用的方法 intrSelf()
    Student.prototype.intrSelf = function(){
      .... .....
    }
    结果： 凡是 Student 生的孩子 都能.inerSelf()来直接调用爹的函数
      比如  lilei.intrSelf();
    
    妈妈叫爸爸 prototype
    孩子叫爸爸  __proto__ 
</code></pre></div><p>​</p> <h2 id="自有属性-和-共有属性"><a href="#自有属性-和-共有属性" class="header-anchor">#</a> 自有属性 和 共有属性：</h2> <div class="language- extra-class"><pre><code>       自有属性：保存在子对象中 归对象个人所以有的属性

       共有属性：保存在原型对象中,归于多个子对象共有的属性
</code></pre></div><p>获取属性值： 二者没有任何差别  子对象.属性名</p> <p>修改属性值:</p> <div class="language- extra-class"><pre><code>          自有属性,可直接用子对象修改
          比如 lilei.sage++;
          
          共有属性,只能用原型对象修改
          如果强行用子对象.共有属性修改 
          会给这个子对象添加一个同名的自有属性。 从此这个子对象和父对象的属性无关了
</code></pre></div><h2 id="内置对象的原型对象"><a href="#内置对象的原型对象" class="header-anchor">#</a> 内置对象的原型对象:</h2> <div class="language- extra-class"><pre><code>      任何一种类型 其实都是由构造函数和原型对象组成。内置类型也是这样。
      Js包括的那些内置类型：
          String Number Boolean
          Array  Date  Math RegExp  Error  Function  Object 
          global  
</code></pre></div><p>​</p> <h2 id="所有内置类型也包含构造函数和原型对象"><a href="#所有内置类型也包含构造函数和原型对象" class="header-anchor">#</a> 所有内置类型也包含构造函数和原型对象：</h2> <div class="language- extra-class"><pre><code>      构造函数: 创建该类型的子对象
      原型对象：保存该类型的所有子对象共有的方法和属性
</code></pre></div><p>比如: Array 类型就包含2部分</p> <div class="language- extra-class"><pre><code>1.数组类型构造函数:
        function Array(){...}
        所以创建数组可以使用new Array()
</code></pre></div><p>​<br>
​    2 数组类型也有一个原型对象 包含所有数组对象公用的函数:
​            为一个类型添加一个共有的自定义函数;
​            何时: 只要项目中 经常对一个类型的对象做一种操作 而这个类型的原型对象中又不包含这种函数。
​<br>
如何: 比如:为所有数组添加求和这种函数
sum
1 在数组类型的原型对象中添加sum函数
2 用数组类型的子对象 调用这个sum</p> <h1 id="面向对象-2"><a href="#面向对象-2" class="header-anchor">#</a> 面向对象</h1> <h2 id="继承-2"><a href="#继承-2" class="header-anchor">#</a> 继承:</h2> <div class="language- extra-class"><pre><code>  原型链
        
    什么是: 由多级父对象 逐级继承 形成链式结果
        作用：
         
          1. 保存了一个对象可用的所有成员 
             将来判断一个对象可以使用那些成员,就看它的原型链
             上有什么成员
            
             如果一个成员在子对象的原型链的某个父级对象上 就可以:子对象.成员  访问
            
             如果一个成员不包含在子对象的原型链的任意一个对象上,就不能用 子对象.成员访问
          
          2. 控制着成员的使用顺序:
              先自有 再共有！
</code></pre></div><h1 id="多态"><a href="#多态" class="header-anchor">#</a> 多态</h1> <p>什么是:</p> <div class="language- extra-class"><pre><code>  一个函数,在不同情况下表现出不同的状态
</code></pre></div><p>包括:</p> <div class="language- extra-class"><pre><code>    1.  重载: 根据传入参数的
    2.  重写:
         
      什么是: 在子对象中定义和父对象中成员完全相同的成员 来覆盖父对象的成员  
</code></pre></div><p>​<br>
​          为什么: 从爹继承来的成员不一定都是好用的！</p> <p>​<br>
​          何时：只要子对象觉得从爹继承来的不好用就要重写！
​             如何：只要在子对象中定义和父对象同名的成员</p> <p>console.dir()  //输出对象的存储结构</p> <h2 id="自定义继承"><a href="#自定义继承" class="header-anchor">#</a> 自定义继承:</h2> <div class="language- extra-class"><pre><code>    何时: 只要觉得现在的爹不好用！就可以用
    如何:
        
        1. 只更换一个对象的爹
            
            子对象__proto__=新爹
            
            问题:__proto__浏览器不推介使用
            
            解决:setPrototypeOf()代替__prpto__ 
            Object.setPrototypeOf(子元素,新爹)
     
  set        of Prototype
  
  设置子元素  的 原型对象 为 新爹
  Object.setPrototypeOf(hmm,father);
     
        2. 同时多个对象的爹
            构造函数.prototype=新老公
            时机: 在创建子对象之前换
</code></pre></div><h1 id="es5"><a href="#es5" class="header-anchor">#</a> ES5</h1> <p>什么是:</p> <div class="language- extra-class"><pre><code>EMAScript 标准的第五个升级版本
</code></pre></div><p>为什么:</p> <div class="language- extra-class"><pre><code> 因为Js这门语言 又很多广受诟病的缺陷
</code></pre></div><p>包括哪些新的规则:</p> <div class="language- extra-class"><pre><code>  &quot;use strict&quot;
</code></pre></div><p>严格模式:</p> <p>什么是:</p> <div class="language- extra-class"><pre><code>  比普通Js运行要求更严格的机制
</code></pre></div><p>为什么:</p> <div class="language- extra-class"><pre><code>  因为Js这门语言 又很多广受诟病的缺陷
</code></pre></div><p>何时：</p> <div class="language- extra-class"><pre><code>  今后所有Js程序都要在严格模式下！
          
          严格模式的新需求: 
          
          1. 禁止给未声明变量赋值！
                旧Js 强行给未声明的变量赋值 
            结果: 会自动在全局创建
                  全局污染 内存泄漏
          
            严格Js中 强行给未声明的变量赋值
            结果: 报错:xxx is not undefined!
            避免内存泄漏和全局污染

         2. 静默失败升级为错误
               静默失败:执行不成功 也不报错！
                   极其不便调试
             严格模式中:静默失败 也会报错！    便于调试
         
         3. 普通函数调用和匿名函数自调中的this不再默认指向window 而是指向undefined
         防止全局污染 内存泄漏  

         4. 禁止使用 arguments.callee
              
            什么是 arguments.callee: 是函数运行时, 专门获得当前正在执行的函数本身。
          
            何时: 递归！        
              为什么:避免紧耦合 避免在函数内写死函数名。



    问题: 递归效率极低！———— 重复计算量太大



    所以 Es5 严格模式 出于性能考虑 禁用了 arguments.callee 就暗示不推介使用递归算法。



    解决：绝大多数的递归可以找循环代替

    为什么:避免紧耦合 避免在函数内写死函数名。



    问题: 递归效率极低！———— 重复计算量太大

    所以 Es5 严格模式 出于性能考虑 禁用了 arguments.callee 就暗示不推介使用递归算法。


    解决：绝大多数的递归可以找循环代替
</code></pre></div><h2 id="保护对象"><a href="#保护对象" class="header-anchor">#</a> 保护对象:</h2> <div class="language- extra-class"><pre><code>    什么是:
        
        控制对象的属性值或对象结构进行的随意篡改
    
    为什么: 
    
        在旧的Js中 对象的属性和结构毫无自保能力。 任何人可在任何时候修改属性值为任何值 也可以随意添加属性和删除属性
   
     何时: 
     
     	需要控制对对象的访问时

  如何：2个层面:        



    

1 保护对象的属性
ES5对对象的属性进行了重新分类
        命名属性: 可用.访问到属性
            又分为:
                数据属性 实际存储属性值的属性。
       
                访问器属性 不实际存储属性值,仅提供对另一个数据属性的保护。
                
        内部属性： 无法用.访问到内部的属性
        
        如何保护数据属性：
            旧js中 数据属性其实就是一个普通的变量 毫无自保能力
        
            ES5 标准中: 每个数据属性都是一个缩微的小对象。 每个小对象中,保存一个属性和三个开关

            如何修改属性的小开关来保护一个属性呢
        
            问题: 不能用.直接修改属性对象内部的开关属性！

      解决：必须用专用的函数解决
    
            Object.defineProperty(
                对象名,
                &quot;属性名&quot;,
                {
                  开关：true/false
                }
            )
    
    问题:writable和enumerable两个开关,任何人都可以随意开关。所以设置这两个起不到保护作用。
</code></pre></div><p>​<br>
​        解决:  只要设置 writeble 和 enumerable
​<br>
都要同时关闭configurable, 目的是禁止修改前两个开关</p> <p>解决:</p> <div class="language- extra-class"><pre><code>   只要设置writable 和 enumerable 都要同时关闭configurable 目的是禁止修改两个开关。 且
</code></pre></div><h2 id="configurable一旦被改为fals-不可逆"><a href="#configurable一旦被改为fals-不可逆" class="header-anchor">#</a> configurable一旦被改为fals 不可逆！</h2> <p>问题:</p> <div class="language- extra-class"><pre><code>   enumerable 只能禁止for in 遍历这个属性 无法阻止用.直接访问这个属性。———— 这是半隐藏 
  解决： 无法解决
  问题： Object.defineProperty()一次只能修改对象中的一个属性。如果外部修改多个属性 就要重复写多遍
  
  解决
  Object.defineProperties(
      对象名,{
        属性名:{
          开关：true/false
        },....
      }
  )

问题: 使用保护属性 规则单调 无法使用自定规则保护属性
</code></pre></div><p>解决:使用访问器属性保护数据属性</p> <div class="language- extra-class"><pre><code>      什么是访问器属性 自己不保存数据,专门提供对其他数据属性的保护。
</code></pre></div><p>何时：</p> <div class="language- extra-class"><pre><code>        只要使用灵活的自定义规则保护数据时 就会要请保镖！
</code></pre></div><p>如何:</p> <div class="language- extra-class"><pre><code>      0. 先将要保护的数据属性  隐形埋名, 并且半隐藏！！
      1. 为对象添加访问器属性,保护属性
         
          1 访问器属性要冒名顶替使用原属性名
          2 访问器属性中包含get set两个属性值
          
          get 负责读取受保护的属性值
          set 中负责先验证再修改受保护的属性值
          
          访问器属性不再需要value和writable。 但是需要设置enumerable 和 configurable
</code></pre></div><p>访问器属性如何发挥作用:</p> <div class="language- extra-class"><pre><code>      因为访问器属性是冒名顶替的所以,外人访问器属性时 和 访问普通属性是一样的
      
      只不过访问器属性执行时, 会自动根据外人做到的操作,来选择get和set 来调用 
</code></pre></div><h1 id="es5-2"><a href="#es5-2" class="header-anchor">#</a> ES5</h1> <p>保护对象</p> <div class="language- extra-class"><pre><code>保护对象的属性:

保护对象的结构: 3 个级别
      1. 禁止添加新属性:
                Object.preventExtensions(obj);
      
            阻止对obj对象添加任何扩展属性 
            原理 每个对象都有一个隐藏的
            
            extensible的属性默认值为true
            preventExtensions(obj)使这个内部隐藏属性改为false
      
      2. 密封：在兼具防扩展的基础上 进一步禁止删除现有属性
          Object.seal(obj);
</code></pre></div><p>​<br>
​    2 件事
​        1. 禁止添加新属性
​          Object的extensible = false
​<br>
2. 禁止删除现有属性
自动将所有属性的configurable 都改为false！ 从此defineProperties中不需要再重复写 configirable:false!
其实今后 大多数对象都要密封！
强调： 虽然密封禁止修改结构 但是属性值随便改！</p> <p>​<br>
​     3. 冻结： 在兼具密封的基础上 进一步禁止删除现有属性 禁止修改属性值！
​        Object.freesze(obj)</p> <p>​<br>
​      3 件事:
​<br>
1. 禁止添加新属性</p> <div class="language- extra-class"><pre><code>              obj的extensidle=false
      
      2. 禁止删除现有属性:
        
          自动 将所有的属性的configurable都改为false！
      
      3. 自动将所有属性的writable都改为false。
</code></pre></div><h2 id="object-create"><a href="#object-create" class="header-anchor">#</a> Object.create()</h2> <p>函数:没有构造函数的情况下，也想到创建一个子对象    子对象继承的简单写法</p> <div class="language- extra-class"><pre><code>3 件事:  
        1.创建一个新对象
        2. 继承一个父对象
        3. 为新对象添加自有属性
       
var 子对象 =  Object.create(父对象,{
        // defineProperties
        属性名:{
          value : 属性值,
          writable:true/false,
          enumerable: true/false,
          configurable : true/false
        }
        ......
}) 
</code></pre></div><h2 id="call-apply-bind-替换this"><a href="#call-apply-bind-替换this" class="header-anchor">#</a> call,apply,bind: 替换this</h2> <p>何时:</p> <div class="language- extra-class"><pre><code>  只要函数执行时 内部this 不是我们想要的
  就可以使用这三个函数 将不想要的this换成任意一个想要的对象。
</code></pre></div><p>如何：</p> <div class="language- extra-class"><pre><code>  1. call,apply: 在一次调用函数时，临时替换一次this！
        要调用的函数.call(替换this的对象，...)
        强调: 实参值列表必须从第二个值开始。
        因为第一个实参的位置让给了替换this的对象！
  原理: 
        call 更大的作用：可让任何对象去调用原本没有任何关系的一个函数。 —————— 抢
</code></pre></div><h2 id="apply-vs-call"><a href="#apply-vs-call" class="header-anchor">#</a> apply vs call:</h2> <div class="language- extra-class"><pre><code>    apply 和 call 用法几乎完全一样。只不过,要求所有的实参值都要放在一个数组中整体传入。

    执行过程：
      1. 先用第一个参数值对象替换函数中的不想要的this。
      2. 打散数组为多个单独的元素值，分别传给对应的每个形参变量

    总结：通常情况下 要替换函数中的this,用call就够了！ 只有实参值类表是放在一个数组中的时候才需要使用apply 先打散再传入函数。
</code></pre></div><h2 id="bind"><a href="#bind" class="header-anchor">#</a> bind</h2> <div class="language- extra-class"><pre><code>bind: 不调用函数,而是基于函数,创建一个新函数副本。并永久替换新函数中的this为指定的对象。
</code></pre></div><p>何时:</p> <div class="language- extra-class"><pre><code>  今后,如果一个函数需要反复调用，又反复替换其中的this时 都是用 bind() 来创建副本,
                  并永久绑定this
</code></pre></div><p>如何:</p> <div class="language- extra-class"><pre><code>      var 新函数 = 旧函数.bind(
          替换this的对象,
          要绑定的实参值,
          ....                                  
      )
</code></pre></div><p>结果:</p> <div class="language- extra-class"><pre><code>1. 新函数的功能和就函数是完全一样的。
2. 但是新函数中的this和开头部分形参,已被永久替换为固定的对象和固定的参数值。
3. 今后调用新函数时,只要传入可能变化的剩余几个实参值即可！
</code></pre></div><h1 id="数组函数"><a href="#数组函数" class="header-anchor">#</a> 数组函数</h1> <div class="language- extra-class"><pre><code>1.数组中查找元素: indexOf 
  
  数组中的indexOf 和字符串的 indexOf 完全一样
  var i = arr.indexOf(&quot;元素&quot;,fromi);
  在arr数组中 从 fromi位置开始 找下一个和指定&quot;元素&quot;相同的元素所在的位置i
      返回值:如果找到 返回 i
              如果没有找到 返回-1
</code></pre></div><p>判断:</p> <div class="language- extra-class"><pre><code>1. 判断数组中是否所有元素都符合要求
      var bool = arr.every(function(value,i,arr){
        //value 当前元素值
        // i 当前索引位置
        // arr 当前数组元素
        return 判断条件;
      })
          
原理 every 会自动遍历arr中的每个元素。
  
每遍历一个元素,就会自动调用一次回调函数function。

每次调用function时,自动传入当前正在遍历的元素值和下标位置,以及当前数组对象,每次调function 都会用函数内的条件检查当前元素会否符合要求 

只有当前元素符合要求 才能继续遍历下一个元素。 只要碰一个不符合要求的元素,就立刻退出遍历 返回false。意思是不是所有元素都满足要求。
如果遍历结束,还没有退出,说明整个数组中都符合要求 整个every(),就返回true
arr[i+1]
</code></pre></div><p>​<br>
​    2. 判断数组中是否包含符合要求的元素
​          var bool =arr.some(function(value,i,arr ){
​                return 判断条件
​          });</p> <p>​<br>
​        用法和every完全相同 只不过执行时 只要碰到一个元素判断为true  就不不再遍历,直接返回true。 只有遍历结束 还没有找到判断为true才返回false;</p> <p>​</p> <h2 id="遍历"><a href="#遍历" class="header-anchor">#</a> 遍历</h2> <div class="language- extra-class"><pre><code>    普通遍历: 代替for循环
        for(var i=0;i&lt;arr.length;i++){
              //i  当前位置 // arr[i] 当前元素值 
        }
</code></pre></div><p>​<br>
​<br>
​            arr.forEach(function(value,i,arr){
​                  //对当前元素执行的操作！
​            })</p> <p>​<br>
​            forEach中自动遍历arr中的每个元素 每遍历一个元素 就在这个元素上自动调用一次回调函数function 自动传入当前元素值给value 当前位置给i 当前数组对象给arr。</p> <p>​<br>
​      遍历并复制原数组为新数组
​              var 新数组=原数组.map(
​                // var newArr=[];//自动
​                // for(var i=0; i&lt;arr.length;i++){}
​                //      arr[i] i this
​                //          ↓  ↓  ↓
​                function(value,i,arr){
​                  return 要放入的新数组中的元素值
​                }
​                //return newArr;//自动
​              )
​        原理:
​<br>
1. map 内先自动创建一个新数组</p> <div class="language- extra-class"><pre><code>        2. 然后才是带着回调函数一起遍历 原数组.自动将回调函数在每个元素上执行一次 将回调函数return的结果 放到新的数组中相同的位置上
        
        3. 遍历结束 返回新数组
    总结:
      
      1. 仅单纯代替 for 循环遍历数组,首选foreach
      
      2. 除非想保护原数组,返回的新数组时 采用map. 
</code></pre></div><p>​<br>
​      过滤和汇总：
​<br>
1. 过滤: 复制出原数组中符合条件的元素组成 新数组返回. 原数组保持不变！</p> <div class="language- extra-class"><pre><code>              var 新数组=原数组.filter(
                function(value,i,arr){
                  return 判断条件
                }
              ) 
              
    原理:
        
        1.先创建一个空数组
        
        2.自动遍历原数组中每个元素 每遍历一个元素 就自动调用一次回调函数 如果当前元素经过回调函数验证,返回true 则加入新数组中 如果当前元素经过回调函数验证 返回false 则不加入新数组.  
        
        3. 遍历结束,返回新数组！
</code></pre></div><p>​<br>
​            2. 汇总： 对数组中的元素内同容进行统计 得出最终结论</p> <p>​<br>
​<br>
​<br>
//作业
1 如何用ES5实现两种类型的继承 ———— 手写
2 如何 判断一个对象是不是数组 共有几种方法！ 6种以上</p> <h1 id="es6"><a href="#es6" class="header-anchor">#</a> ES6</h1> <h2 id="什么是-ecmascript-第6个版本"><a href="#什么是-ecmascript-第6个版本" class="header-anchor">#</a> 什么是:ECMAScript 第6个版本</h2> <p>优点: 在不改变原理的基础上 简化了Js代码</p> <p>问题: 兼容性</p> <div class="language- extra-class"><pre><code>  包括:

      let:
          什么是:  专门代替var 来声明变量用
         
          为什么:  var 的问题:
              1. 声明提前
              2. 没有块级作用域
         
          何时: 只要声明变量都用 let
         
              优点：
                  1.阻止了声明提前
                  1. 添加块级作用域
         
          原理: let 其实就是一个匿名自调!
                且let 为了双保险 其实底层悄悄给变量改了名字
</code></pre></div><p>​<br>
​              let 小脾气
​                  1 在相同作用域/块内，禁止同时let两个同名的变量
​<br>
2 在let a之前到当前作用域顶不允许提前使用 a 变量</p> <h2 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数:</h2> <p>什么是  对普通函数声明的简写</p> <div class="language- extra-class"><pre><code>      何时： 今后绝大多数匿名函数的创建 都用箭头函数。

          如何 3件事

              1 去掉 function 在()和{}之间=&gt;
              
              2 如果形参列表只有一个变量 可省略()
              
              3 如果函数体只有一句话 可省略{}
              但是 如果仅有的这句话 还是return 则必须省略return
              去掉{}时 还要注意去掉语句结尾&quot;;&quot;

        双刃剑
            
            让函数内外this连通 保持一致。都指向函数外this
        
        结论: 如果希望函数内的this和函数外的this 不一致时！ 就不能用箭头函数！

        比如： 对象的方法不能用箭头函数简写
        
        比如： DOM中的事件处理函数也不能用箭头函数简写
</code></pre></div><p>​<br>
​           问题  一旦改为箭头函数则不能使用arguments</p> <h2 id="for-of"><a href="#for-of" class="header-anchor">#</a> for of</h2> <p>什么是 在特定情况下专门简化for循环</p> <div class="language- extra-class"><pre><code>        总结:  遍历一个数组：
  
            1.for(var i=0;i&lt;arr.length;i++){
                ....
            }
              优点: 即可控制遍历的方向 有可遍历循环的步调
</code></pre></div><p>​<br>
​                2.arr.forEach((elem,i,arr)=&gt;{
​                  //当前元素 elem
​                });
​<br>
局限: 不能控制遍历的方向 也不能控制便利的步调</p> <div class="language- extra-class"><pre><code>            3. for of
                  如何:for(var elem of 数组){
                    
                    //of 会依次取出数组每个元素值，保存在of前的变量elem中
                  
                  }  
</code></pre></div><p>​<br>
​                  局限: 只能获得元素值 无法获得当前元素位置
​<br>
其实 for of 不但可以用于数组 还可以用于字符串,类数组对象,单个数值</p> <div class="language- extra-class"><pre><code>              总结: for of 可以遍历数字下标数组, 类数组对象,字符串 中的每个字。

              for in 专门遍历自定义下标的关联数组 和对象。
</code></pre></div><h2 id="参数增强"><a href="#参数增强" class="header-anchor">#</a> 参数增强</h2> <div class="language- extra-class"><pre><code>    什么是:ES6中对函数的参数 提供了更强大,更方便的功能
</code></pre></div><p>包括:</p> <ol><li><p>参数默认值(default);</p> <div class="language- extra-class"><pre><code> function 函数名(形参,..,形参n=默认值){
   如果没有传入最后一个参数 则使用默认值作为备胎 
 }  
 ES5 的代替方式:形参 n=形参n||默认值
 如果形参n是有意义的值不是false&quot;&quot;,undefined,null,NaN 就用 形参n 的值继续向后执行

 // 如果 形参n是没有意义的值 就用默认值作为备胎

 强调: 局限 只能解决最后一个形参不确定的情况。
</code></pre></div></li> <li><p>剩余参数(rest);</p> <div class="language- extra-class"><pre><code> 什么是:专门代替arguments
 为什么:arguments的问题:
   
   1. 不是纯正的数组类型 用不了数组家的函数
   
   2. 不支持箭头函数
   何时: 今后只要使用arguments的地方都可以使用rest语法代替
   
   如何:
       定义函数时：
         function fn(形参1,形参2,...数组名){
   
           //...后的数组会接住除之前形参外的其他所有剩余实参值
           
           // 数组是纯正的数组类型可随意使用数组家的函数
           //即使fun改为箭头函数 依然可以使用...数组名的rest语法 
         } 
</code></pre></div><p>​<br>
3. 打散数组(spead);</p> <p>为什么:</p> <div class="language- extra-class"><pre><code>     代替apply 
</code></pre></div><p>apply的问题是 本职工作不是打散数组，而是替换this 顺便打散数组。</p> <p>何时:</p> <div class="language- extra-class"><pre><code>     今后只要希望将一个数组整体 打散为单个值
</code></pre></div><p>如何： 传递参数或赋值时</p> <div class="language- extra-class"><pre><code>     fun(..arr)
     先将arr中的元素值打散为单个值 再分别传给fun()
</code></pre></div><p>项目中:</p> <div class="language- extra-class"><pre><code>   1. 拼接两个数组
       var arr1 = [1,2,3],arr2=[4,5,6];
       var arr = [...arr1,arr2];
       arr=[1,2,3,4,5,6]
   2. 合并两个对象
       var obj1={x:1},obj2={b:2};
       var  obj = {...obj1,...obj2}
       obj:{x:1,b:2};
</code></pre></div><p>解构:</p> <p>什么是:</p> <div class="language- extra-class"><pre><code>   将一个大的对象或数组中的个别成员 提取出来,单独使用
</code></pre></div><p>何时:</p> <div class="language- extra-class"><pre><code>   如果给的是一个巨大的对象,而我们这个功能，
  只需要其中个别函数或者属性时 就要将所需的成员解构 出来 单独使用。
</code></pre></div><p>如何：</p> <div class="language- extra-class"><pre><code>       1 数组解构：
           什么是: 将大的数组中的个别元素提取出来单独使用。
           如何:下标对下标
               [变量1,变量2,...]=数组
                  0     1  ... 
                结果: 变量1 = 数组[0]
                      变量2 = 数组[1]
</code></pre></div><p>​<br>
​            2 对象解构
​              什么是: 将大的数组中的个别元素提取出来单独使用
​<br>
如何： 属性名对属性名
{属性名1:变量1,属性名 2: 变量2,...}=对象</p> <div class="language- extra-class"><pre><code>               结果: 变量1=对象.属性名 1
               
               变量2 = 对象.属性名2
               
         简写 如果新变量的名字延用成员对象中的属性名,则可以简写 
               
               比如:user 对象中 解构出登录方法和注册方法单独使用
 
               var {signin:signin,signup:signup}=user
               可简写:
               var {signin,signup} =user; 
</code></pre></div></li></ol> <h2 id="参数结构"><a href="#参数结构" class="header-anchor">#</a> 参数结构</h2> <p>什么是</p> <div class="language- extra-class"><pre><code>    在定义函数和调用函数时采用对象结构传递参数。
</code></pre></div><p>何时:</p> <div class="language- extra-class"><pre><code>    多个形参值不确定有没有 而且有要求实参值与形参值之间必须对应。
</code></pre></div><p>为什么:</p> <div class="language- extra-class"><pre><code>    默认值: 局限;只有最后一个形参不确定时 才能使用默认值
    ...rest 和 arguments；局限; 无法让形参值与实参值一一对应。
</code></pre></div><p>用对象结构传参:</p> <p>问题:</p> <div class="language- extra-class"><pre><code>    定义函数时只有一个对象形参 将来调用者不知道具体形参个数和名称！
</code></pre></div><p>如何：2步</p> <div class="language- extra-class"><pre><code>    1 定义函数时 形参写成对象语法！
    
    2 调用函数时 所有实参必须放在一个形参对象结构相同的对象中传入
</code></pre></div><h1 id="es6-2"><a href="#es6-2" class="header-anchor">#</a> ES6</h1> <h2 id="面向对象上的简化"><a href="#面向对象上的简化" class="header-anchor">#</a> 面向对象上的简化：</h2> <h3 id="对单个对象提供了2处简化"><a href="#对单个对象提供了2处简化" class="header-anchor">#</a> 对单个对象提供了2处简化</h3> <div class="language- extra-class"><pre><code>  如果对象的属性提供了2处简化
  
        1. 如果对象的属性值来自于对象外的变量,且变量名刚好和属性名相同 则不用写两遍相同的名字 只要写一遍即可。
  
        2. 所有对象的方法,不再需要写&quot;:function&quot;
            强调:对象的方法去掉:function 不等效于箭头函数 突出的特点 this保持不变！
            所以 去掉:function,只是单纯的简写 没有任何原理的改变！
</code></pre></div><p>​</p> <h2 id="class"><a href="#class" class="header-anchor">#</a> Class:</h2> <p>什么是:</p> <div class="language- extra-class"><pre><code>    集中定义一种类型的所有对象统一属性结构和方法的程序结构。
</code></pre></div><p>为什么</p> <div class="language- extra-class"><pre><code>    每一种类型 Array Student Date  都有两部分组成 构造函数+原型对象
</code></pre></div><p>构造函数:</p> <div class="language- extra-class"><pre><code>      负责定义 子对象统一的属性结构,并且负责创建子对象
</code></pre></div><p>原型对象:</p> <div class="language- extra-class"><pre><code>    负责保存所有子对象共有的属性值和方法
    但是,在ES5中 构造函数和原型对象是分开定义的。 不符合&quot;封装&quot;的要求
</code></pre></div><p>何时:</p> <div class="language- extra-class"><pre><code>    今后只要希望创建一种自定义类型时 都用class
</code></pre></div><p>如何: 3件事</p> <div class="language- extra-class"><pre><code>  1. 用class{}包裹 构造函数和原型对象方法
 
  2. 构造函数名提升为class名 所有构造函数,从此统一更名为constructor
  
  3. 所有放在class中的函数,不需要加类型名.prototype前缀,自动就保存在构造函数的原型对象中。
</code></pre></div><p>如何使用 class: 用法和从前的构造函数完全一样！
原型对象的原理依然保持不变。</p> <div class="language- extra-class"><pre><code>2. 两种类型间的继承:
          
          问题： 两种类型之间包含部分相同的属性结构和方法定义。
          解决： 定义一个上层的父类型,集中保存两种子类型相同部分。
          extends
</code></pre></div><h1 id="promise"><a href="#promise" class="header-anchor">#</a> Promise:</h1> <p>什么是</p> <div class="language- extra-class"><pre><code>  专门保证多个异步函数 可以顺序执行的机制 而且还防止了回调地狱的问题
</code></pre></div><p>何时:</p> <div class="language- extra-class"><pre><code>    多个异步调用的函数  要求必须顺序执行！
</code></pre></div><p>为什么：</p> <div class="language- extra-class"><pre><code>    其实用回调函数，也可以实现多个异步函数,顺序执行 但是 使用回调函数
    会有回调地狱问题！
</code></pre></div><p>问题1  多个异步函数要求顺序执行</p> <div class="language- extra-class"><pre><code>    错误的解决 仅按顺序调用
          结果 无法保证顺序执行
          因为 多个异步函数 相当于百米赛跑 每人之各占一条跑道 互相不会等待
  
    传统解决办法:使用回调函数
              
              1. 在定义函数时 定义一个callback形参变量 
                  在函数内部 最后一句话执行之后自动调用callback（）
              
              2. 在调用函数h时,传入一个函数 函数中包含
              下一步要执行的操作 ———— 提前托付
               效果   当前一个函数调用时 暂时不执行 传入的小函数
               只有前一个函数最后一句话执行完 才自动调用传入的小函数
               一次保证小函数一定会在异步函数调用完才执行  
               问题 当连续执行的异步函数非常多时就会形成回调地狱！
</code></pre></div><p>解决:ES6 Promise</p> <div class="language- extra-class"><pre><code>    多个异步函数要求顺序执行
    
    .then()能接受下一个.then(),取决于前一个.then()中的函数是否也支持Promise。如果前一个.then()中的函数支持Promise 则.then()可以继续.then()。
      
    如果前一个.then()中的函数不支持Promise 则不能继续.then()
</code></pre></div><p>前后两个函数间传参:</p> <div class="language- extra-class"><pre><code>      2步:
  
      1. 上一步函数中 door(参数值)
  
      2. 下一个函数定义时就要定义一个形参准备接
         原理 当上一个函数调用 door(参数值)时,参数默认值 会顺着.then()交给.then()中的下一个函数的形参变量。
         在下一个中 就可通过自己的形参变量获得上一步传下来的参数值
</code></pre></div><p>​<br>
​      局限：
​<br>
door()中只能传一个变量 如果必须穿多个值 则可以将多个值放在数组或对象中整体传入。</p> <p>​<br>
错误处理:
​<br>
​              如何: 任何一个支持 Promise的函数中都有另一扇门 如果当前异步任务执行过程中发生错误就可以从另一扇门出来 一旦从报错这扇门出来后,后续.then()都不再执行</p> <p>​<br>
​            其实new Promise() 除了.then外 还有另一个方法.catch() 凡是从出错的门出来的代码都进入.catch()中执行错误处理操作
​<br>
等待多个异步任务完成才执行:
Promise.all([
多个支持Promise的函数调用(),
...,
...,<br>
]).then(function(){后续操作...})</p> <div class="language- extra-class"><pre><code>        问题：如果每个异步任务都返回一个接力棒 则如何获得所有接力棒呢？

      解决：.then(function(arr){...})
          其中 arr数组中保存了Promise.all 中所有异步函数通过door()返回执行结果
      强调: arr中返回值存储的顺序和异步函数执行完成的顺序无关 只和调用的顺序有关！
</code></pre></div><p>​</p> <h2 id="一个promise有三个状态"><a href="#一个promise有三个状态" class="header-anchor">#</a> 一个Promise有三个状态</h2> <div class="language- extra-class"><pre><code>            1. pending:挂起 异步任务正在执行还没有执行完
                            
            2. resolve:同意 当异步任务执行完,且执行成功,主动调用 door()函数  会将Promise对象的状态 改为 resolve 当Promise对象状态改为resolve 就会自动执行.then()中的函数
                           
             3. reject: 拒绝 当异步任务执行完 且执行失败 主动调用err()函数  会将Promise对象的状态 改为reject  当Promise对象的状态 一旦被改为reject后 会自动调用  catch()中的函数
</code></pre></div><p>​</p> <h2 id="promise的问题-并没有彻底消灭嵌套"><a href="#promise的问题-并没有彻底消灭嵌套" class="header-anchor">#</a> Promise的问题 并没有彻底消灭嵌套</h2> <div class="language- extra-class"><pre><code>        比如 .then(weimin) 
            .then(function(){
                console.log(&quot;比赛结束&quot;)
            })
            .catch(function(err){
                错误处理
            })
</code></pre></div><p>​<br>
解决:ES7： async  awiat 可按照传统同步指定的
​<br>
​          代码一样 编写异步代码顺序执行
​<br>
只要多个异步任务需要顺序执行:</p> <div class="language- extra-class"><pre><code>          (async function(){
              同步代码;
              await 异步函数();
              同步代码
          })();
</code></pre></div><p>​<br>
​        其中 await 可让整段匿名函数自调暂时挂起 等待当前异步函数执行完 在执行后续代码！
​<br>
强调：es7 的 async 和 await 仅仅简化的是Promise函数 调用的部分。而并没有简化 Promise 函数的定义 且 如果想用await 则异步函数
必须定义为支持Promise的样式</p> <div class="language- extra-class"><pre><code>  错误处理 如果await修饰的异步函数 中调用了err()方法 打开了错误的门 则await 会认为是程序错误  
  
  应该用 try{}catch(err){}来解决
  强调: 只有async下的try catch 才能捕获异步任务中的错误 没在async下的Js基础中所学的trycatch是不能捕获异步任务的！因为普通Js基础中的try catch 属于主程序 不会等待异步任务执行 就已经结束了 即使异步任务出错 try catch 因为早就结束了 所以根本捕获不到
</code></pre></div><p>​<br>
​      为什么 await 配合 try catch 就可以捕获异步任务中的错误呢？
​      因为 await 可以留住当前程序中的一切代码 等待异步函数执行完。
​      try catch 就可能捕获到异步任务中的错误</p> <p>​</p> <p>​</p> <p>​</p> <p>​</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.4f367505.js" defer></script><script src="/assets/js/2.cfe6598b.js" defer></script><script src="/assets/js/84.81e6ba36.js" defer></script><script src="/assets/js/3.fb60532c.js" defer></script>
  </body>
</html>
