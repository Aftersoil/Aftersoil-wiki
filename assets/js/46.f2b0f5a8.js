(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{453:function(a,s,n){"use strict";n.r(s);var t=n(22),e=Object(t.a)({},(function(){var a=this,s=a.$createElement,n=a._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"js-正则表达式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-正则表达式"}},[a._v("#")]),a._v(" JS 正则表达式")]),a._v(" "),n("p",[a._v("概述  正则表达式 专门描述字符串中字符串出现规则的表达式")]),a._v(" "),n("h2",{attrs:{id:"正则表达式用于"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式用于"}},[a._v("#")]),a._v(" 正则表达式用于:")]),a._v(" "),n("ol",[n("li",[a._v("验证字符串格式")]),a._v(" "),n("li",[a._v("查找敏感词")])]),a._v(" "),n("h2",{attrs:{id:"定义正则表达式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#定义正则表达式"}},[a._v("#")]),a._v(" 定义正则表达式")]),a._v(" "),n("ul",[n("li",[n("h3",{attrs:{id:"使用字符集简写"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用字符集简写"}},[a._v("#")]),a._v(" 使用字符集简写")]),a._v(" "),n("ul",[n("li",[a._v("多选一规则匹配\n[备选方案]\n[卧我]\n[0-9] 区间内选一")])])]),a._v(" "),n("li",[n("h2",{attrs:{id:"其他简写"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#其他简写"}},[a._v("#")]),a._v(" 其他简写")]),a._v(" "),n("ol",[n("li",[a._v("匹配一位小写音文字母 [a-z] 共26个")]),a._v(" "),n("li",[a._v("匹配一位大写音文字母 [A-Z] 共26个")]),a._v(" "),n("li",[a._v("要匹配一位字母 [A-Za-z] 共52个")]),a._v(" "),n("li",[a._v("要匹配一位字母或数字 [0-9A-Za-z] 共62个")])]),a._v(" "),n("h2",{attrs:{id:"_5-要匹配一位汉字-u4e00-u9fa5-19968-40869-共20902个"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-要匹配一位汉字-u4e00-u9fa5-19968-40869-共20902个"}},[a._v("#")]),a._v(" 5. 要匹配一位汉字 [\\u4e00-\\u9fa5] 19968~40869 共20902个")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      例子:\n      利用字符集简写定义车牌号规则\n      1. 第一位  1位汉字\n      2. 第二位  1位大写字母\n      3. 第三位   .\n      4. 后五位  每一位 都是一位大写字母或数字 \n  \n      答案:[\\u4e00-\\u9fa5][A-Z].[0-9A-Z][0-9A-Z][0-9A-Z][0-9A-Z][0-9A-Z] \n")])])])]),a._v(" "),n("li",[n("h3",{attrs:{id:"预定义字符集"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#预定义字符集"}},[a._v("#")]),a._v(" 预定义字符集")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("- 要匹配一位数字: \\d 等效于[0-9];\n- 要匹配一位字母,数字或:\\w 等效于 [0-9A-Za-z];\n- 要匹配一位空字符 \\s 可匹配 空格,制表符Tab 等 空白\n- 要匹配所有(通配符)  .\n")])])])])]),a._v(" "),n("p",[a._v("手机号规则可进一步简写:\n1[3-8]\\d\\d\\d\\d\\d\\d\\d\\d\\d")]),a._v(" "),n("ul",[n("li",[n("h1",{attrs:{id:"数量词"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数量词"}},[a._v("#")]),a._v(" 数量词")]),a._v(" "),n("ul",[n("li",[a._v("手机号实例   \\d{9} 等同于 \\d * 9 次\n例 : [3-9]\\d{9}")]),a._v(" "),n("li",[a._v("车牌号简写\n例 : [\\u4e00-\\u9fa5][A-Z].[A-Z0-9]{5}")])])]),a._v(" "),n("li",[n("h3",{attrs:{id:"数量词-包含两大类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数量词-包含两大类"}},[a._v("#")]),a._v(" 数量词 包含两大类")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("有明确数量边界的数量词")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("   - 字符集{n} 表示字符集必须重复n次 不能多也不能少\n   - 字符集{n,m} 表示字符集至少重复n次 最多重复 m 次\n     比如： \\d{4,6}\n   - 字符集{n,}表示字符集匹配内容至少 重复n 次 多了不限\n")])])])]),a._v(" "),n("li",[n("p",[a._v("没有明确数量边界的数量词")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("   - \\* 可有可无 多了不限\n   - ？ 可有可无 最多一次\n   - \\+  至少一次 多了不限\n   - \\s*   \\s+  \\s?\n")])])])])])])]),a._v(" "),n("ul",[n("li",[n("p",[a._v("例子:\n匹配手机短信中验证码  连续4为 到 6位的手机号")]),a._v(" "),n("p",[a._v("正则表达式 大部分情况采用 贪婪模式进行匹配\n尽量匹配最长的关键词")])])]),a._v(" "),n("ul",[n("li",[n("h2",{attrs:{id:"选择和分组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#选择和分组"}},[a._v("#")]),a._v(" 选择和分组")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("选择 指多个子规则选择其一进行匹配")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" 子选择1 | 子选择2\n")])])])]),a._v(" "),n("li",[n("p",[a._v("分组 多个子规则分为一组 再和分组外的规则匹配")])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("其他规则(多个子规则)\n\n例: ([我卧]|wo)\\s*([草艹槽]|cao)\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[n("p",[a._v("定义完整手机号规则")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" - +86 或 0086\n - (\\+86|0086)\n - 至少一个空字符:\\s+ \n - 之前所有可有可无 至少一次()?\n - 1 \n - 3~8 任选其一\n - 0-8\n   \\\\+ 转义字符\n")])])]),n("p",[a._v("答案: ((+86|0086)\\s+)?1[3-8]/d{9}")])]),a._v(" "),n("li",[n("p",[a._v("定义完整身份证号规则")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" - 15位数字 \\d{15}\n - 2位数字 \\d\\d\n - 最后一位:  1位数字 或 X[0-9x]\n - 最后三位 可有可无 虽多一次\n\n 定义完整身份证正则\n \\d{15}(\\d\\d[0-9x])?\n")])])])])])])]),a._v(" "),n("p",[a._v('作业需求:  匹配 "微信","weixin","w x" 等情况 并防止 中间加空格')]),a._v(" "),n("ul",[n("li",[n("h2",{attrs:{id:"指定匹配位置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#指定匹配位置"}},[a._v("#")]),a._v(" 指定匹配位置")]),a._v(" "),n("ul",[n("li",[n("p",[a._v("使用情况  如果只希望匹配特殊位置上的关键词时 就可以使用特殊符号 表示特殊位置")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" 1. ^ 表示字符串开头  \n 2. $ 表示字符串结尾\n 3. \\b 表示单词边界,可匹配: 空格 标点符号 字符串开头和结尾等 可将一个单词与其他单词分割开的符号\n")])])])])]),a._v(" "),n("p",[a._v("找到开头和结尾空格")]),a._v(" "),n("p",[a._v("例如 ^\\s+$ //错误写法")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      正确写法     \n     ^\\s+|\\s+$\n")])])]),n("ul",[n("li",[n("p",[a._v("常见面试题")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  - 找到每个单词的首字母\n  - ———— 前边紧挨着的单词边界字母\n  ^\\b[A-Za-z]\n")])])])])])])]),a._v(" "),n("p",[a._v("作业需求")]),a._v(" "),n("p",[a._v("使用正则匹配电子邮件: ___ 记住")]),a._v(" "),n("ul",[n("li",[n("h2",{attrs:{id:"string-的正则函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#string-的正则函数"}},[a._v("#")]),a._v(" String 的正则函数")]),a._v(" "),n("ul",[n("li",[n("p",[a._v("查找敏感词  4种情况")]),a._v(" "),n("ul",[n("li",[n("p",[a._v("1 查找一个固定的敏感词位置 i;")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('var i=str.indexOf("敏感词",fromi)\n')])])]),n("p",[a._v("在str中 从 fromi 开始 向后查找下一个“敏感词”的下标位置 i")]),a._v(" "),n("p",[a._v("找到 返回敏感词第一个字的下标位置\n没找到返回 -1")]),a._v(" "),n("p",[a._v("问题: indexOf 只能查找固定的敏感词 而且不支持正则！")])]),a._v(" "),n("li",[n("p",[a._v("2  用正则表达式 模糊查找多种敏感词")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" -  var i = str.search(/正则/i)\n   -  i 不区分大小写\n   - 原理和用法几乎相同\n   - 差别\n       - 1 用灵活的正则表达式 代替了写死的敏感词 \n       - 2 只有一个参数 不能指定开始的位置 永远只能从头开始找  \n")])])])])])])])]),a._v(" "),n("li",[n("h2",{attrs:{id:"扩展-test"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#扩展-test"}},[a._v("#")]),a._v(" 扩展 .test()")]),a._v(" "),n("ul",[n("li",[n("p",[a._v("test() 方法是正则表达式的一个方法，用于检测一个字符串是否匹配某个模式")])]),a._v(" "),n("li",[n("p",[a._v("如果是则返回 true，否则就返回 false")])]),a._v(" "),n("li",[n("p",[a._v("regexp.test(str)")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("手机号验证：!/^[1][3,4,5,7,8][0-9]{9}$/.test(this.phone)\n")])])])])])])]),a._v(" "),n("hr"),a._v(" "),n("h1",{attrs:{id:"string-正则函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#string-正则函数"}},[a._v("#")]),a._v(" String 正则函数")]),a._v(" "),n("h2",{attrs:{id:"查找敏感词"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#查找敏感词"}},[a._v("#")]),a._v(" 查找敏感词")]),a._v(" "),n("p",[a._v("4种")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("固定敏感词出现的位置")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('     var i = str.indexOf("敏感词",fromi);\n   没有给定值 从0开始找\n   没找到返回-1\n   问题： 如果换成同音字或拼音,就找不到了\n')])])])]),a._v(" "),n("li",[n("p",[a._v("用正则表达式模糊查找一个敏感词的位置")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("       var i=str.search(/正则表达式/i) \n   问题：只能返回敏感词的位置 不能返回敏感词具体的内容\n")])])])]),a._v(" "),n("li",[n("p",[a._v("获取敏感词内容 2种")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('   - var arr = str.match(/正则/i)\n   - 在str中 查找一个符合正则要求的敏感词的内容和位置\n   - 返回值 返回一个数组 \n   - 没找到 返回null \n   - 如果想获得本次查找的内容 arr[0]  \n   - 如果想获得本次查找的位置  arr\n \n   ["index"] 必须添加 ""\n \n   正则表达式只能匹配一个敏感词 -g 找出所有\n \n   str.match(//ig);\n     \n     问题:  如果match+g 只能返回敏感词内容 无法返回敏感词位置 \n     如果只关心 敏感词内容  就使用 match+g \n')])])])])]),a._v(" "),n("h2",{attrs:{id:"强调"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#强调"}},[a._v("#")]),a._v(" 强调")]),a._v(" "),n("ul",[n("li",[n("h4",{attrs:{id:"如果一个函数有可能返回null-则使用前必须先验证-是不是null-才能使用-因为null之后-什么都不可以加-null-报错-null-报错"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如果一个函数有可能返回null-则使用前必须先验证-是不是null-才能使用-因为null之后-什么都不可以加-null-报错-null-报错"}},[a._v("#")]),a._v(" 如果一个函数有可能返回null! 则使用前必须先验证 是不是null 才能使用  因为null之后 什么都不可以加 null 报错 null. 报错")])]),a._v(" "),n("li",[a._v("${arr!=null?arr.length:0}")])]),a._v(" "),n("h1",{attrs:{id:"js-底层数组都是关联数组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-底层数组都是关联数组"}},[a._v("#")]),a._v(' Js 底层数组都是关联数组  "" : ""')]),a._v(" "),n("h3",{attrs:{id:"arr-length-arr-length-数字下标不能简写-与小数点冲突"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#arr-length-arr-length-数字下标不能简写-与小数点冲突"}},[a._v("#")]),a._v(' arr.length arr["length"]  数字下标不能简写!  与小数点冲突')]),a._v(" "),n("ol",{attrs:{start:"4"}},[n("li",[n("p",[a._v("既查找每个关键词的内容 又查找关键词的位置")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("   - RegExp对象 exec() 函数\n")])])])])]),a._v(" "),n("h1",{attrs:{id:"替换敏感词"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#替换敏感词"}},[a._v("#")]),a._v(" 替换敏感词")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("简单替换 将所有敏感词替换统一新词")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('  str = str.replace(/正则/ig,"新词")\n\n   坑： 替换后 不报错也替换不成功\n\n   因为 字符串都是不可变类型 ！\n        无法对原字符串直接进行修改\n        所有字符串函数 都只能返回修改后的字符串 而保持原字符串不变\n   解决 想要获得新值 必须用=接住新值保存到变量中\n')])])])]),a._v(" "),n("li",[n("p",[a._v("高级替换 根据每次找到的敏感词不同 动态选择不同的新词替换！")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    //replace 会自动在每个找到的关键词上调用一次这个\n  \n   //回调函数 找到几个词 就反复调用几次 每次调用时 会\n  \n   //自动将本次找到的关键词传给函数keyword\n")])])])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("2个要求\n                \n      function(keyword){\n         1 必须有一个参数接住本次找到的一个关键词\n      \n         2 必须返回处理后的新词\n            return keyword.toLocaleUpperCase();\n          }\n          \n        所有形参可自己定义参数名\n        补 回调函数 callback 我们自己定义的 但不是我们自己调用去执行 而是交给其他对象去执行\n")])])]),n("p",[a._v('衍生：删除敏感词 其实就是将敏感词替换为""')]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('    function trim(str){\n        return str.replace(/^\\s+|\\s+$/,"");\n        }\n')])])]),n("ol",{attrs:{start:"3"}},[n("li",[a._v("切割敏感词")])]),a._v(" "),n("p",[a._v("什么是 根据指定的切割符 切割成多段字符串")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('2种: \n\n    1. 简单切割  切割符是固定的\n       - var arr = str.split("切割符");\n       * 将字符串 str \n    \n    2. 复杂切割 : 切割符是变化的 但是有规律的。 \n    \n       - var arr=str.split(/正则/)\n    \n       - 例如按照空格进行分割\n    \n     - 衍深操作：打撒字符串为字符数组\n')])])]),n("ul",[n("li",[a._v("总结：\n"),n("ul",[n("li",[n("p",[a._v("查找敏感词")]),a._v(" "),n("ul",[n("li",[n("ol",[n("li",[n("p",[a._v("查找一个固定的敏感词")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('str.indexOf("敏感词",fromi);\n')])])])])])]),a._v(" "),n("li",[n("ol",{attrs:{start:"2"}},[n("li",[n("p",[a._v("使用正则模糊查找一个敏感词位置")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("str.search(/正则/i)\n")])])])])])]),a._v(" "),n("li"),a._v(" "),n("li",[n("ol",{attrs:{start:"3"}},[n("li",[a._v("用正则查找一个敏感词的内容")])])])])]),a._v(" "),n("li",[n("ol",[n("li",[n("p",[a._v("只查找一个敏感词的位置 和内容")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("          var arr = str.match(/正则/i)\n")])])])])])]),a._v(" "),n("li",[n("ol",{attrs:{start:"2"}},[n("li",[n("p",[a._v("查找全部敏感词内容 但无法获取位置")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" str.match(//ig);\n")])])]),n("ul",[n("li",[n("ol",{attrs:{start:"4"}},[n("li",[a._v("既查找每个敏感词内容 又查找每个敏感词的位置")])])])])])]),a._v(" "),n("ul",[n("li",[a._v("替换敏感词\n"),n("ul",[n("li",[a._v("删除")])])]),a._v(" "),n("li",[a._v("切割\n"),n("ul",[n("li",[a._v("打撒字符串为字符数组")])])])])])])])]),a._v(" "),n("h2",{attrs:{id:"regexp对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#regexp对象"}},[a._v("#")]),a._v(" RegExp对象:")]),a._v(" "),n("ul",[n("li",[n("p",[a._v("专门保存一条正则表达式 并提供正则执行查找和验证方法的对象\n何时:")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("验证时")])]),a._v(" "),n("li",[n("p",[a._v("高级查找时\n如何:")])]),a._v(" "),n("li",[n("p",[a._v("创建对象:2种")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("简化版创建")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" var reg = /\\b[a-z]ig;\n")])])]),n("p",[a._v("何时 如果正则表达式固定不变的w\n问题 不支持动态生成正则表达式\n因为://之间是正则表达式的地盘 js不认识")])]),a._v(" "),n("li",[n("p",[a._v("用new创建")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(' var reg = RegExp("\\b[a-z]","ig");\n')])])]),n("p",[a._v("何时  如果正则表达式需要根据变量数组内容 动态生成！")]),a._v(" "),n("p",[a._v('因为：这种方法用js认识的""代替了// 而在js中 有很多办法 灵活的拼接想要的字符串')])])])]),a._v(" "),n("li",[n("p",[a._v("RegExp")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("验证格式：")]),a._v(" "),n("p",[a._v("var bool = reg.test(str);")])])])])]),a._v(" "),n("p",[a._v("用reg规则 检测str 是否符合规则要求\n返回值：true/false")]),a._v(" "),n("p",[a._v("坑: test 默认只要在str 中找到部分 和 reg 匹配的 就返回true ！ 而不要求 从头到尾匹配")]),a._v(" "),n("h2",{attrs:{id:"解决-凡是验证-都要求从头到尾必须完整匹配"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解决-凡是验证-都要求从头到尾必须完整匹配"}},[a._v("#")]),a._v(" 解决：凡是验证 都要求从头到尾必须完整匹配")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("   前加 ^ 结尾加 $ \n")])])]),n("p",[a._v("意味从头到尾")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("   只要使用test 必须使用 前后+^$\n")])])])])]),a._v(" "),n("h1",{attrs:{id:"regexp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#regexp"}},[a._v("#")]),a._v(" RegExp :")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("验正字符串格式 bool= reg.test();")])]),a._v(" "),n("li",[n("p",[a._v("既查找内容 有查找关键词的位置")]),a._v(" "),n("p",[a._v("var arr = reg.exec(str);")]),a._v(" "),n("p",[a._v("在str 中查找下一个关键词的位置和内容")]),a._v(" "),n("p",[a._v("返回值 和match 不加 g 的时候是相同的\n知道到 arr[0:关键词的内容,index: 位置]\n如果没有找到返回null")])])]),a._v(" "),n("h2",{attrs:{id:"function"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#function"}},[a._v("#")]),a._v(" Function")]),a._v(" "),n("h2",{attrs:{id:"什么是"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是"}},[a._v("#")]),a._v(" 什么是：")]),a._v(" "),n("p",[a._v("用途 保存一段可重用的代码段的程序结构 再起一个名字")]),a._v(" "),n("p",[a._v("本质 内存中保存一段代码段的存储空间--")]),a._v(" "),n("h2",{attrs:{id:"为什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么"}},[a._v("#")]),a._v(" 为什么：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("代码重用\n何时 只要一段代码 可能被反复使用 都要定义在一个函数内 再起个名字 今后 用函数名等于用代码段\n")])])]),n("p",[a._v("如何")]),a._v(" "),n("p",[a._v("创建函数 3种")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("       1. function 函数名 (形参列表){\n          函数体\n          return 返回值\n       }\n")])])]),n("p",[a._v("形参是什么")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("          专门接受 从函数外部传入函数内部数据的变量\n")])])]),n("p",[a._v("为什么")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("          有些函数执行时  需要动态获得必须的数据 才能正常执行\n")])])]),n("p",[a._v("何时")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("          只要一个函数 必须某些数据 才能正确执行\n")])])]),n("p",[a._v("返回值")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      什么是  一个函数的执行结果\n      \n      为什么 外部调用者可能需要获得函数执行结果\n      \n      何时   只要外部调用者 需要获的函数的执行结果\n")])])]),n("p",[a._v("笔试问题")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("问题  会被声明提前\n")])])]),n("p",[a._v("什么是")]),a._v(" "),n("p",[a._v("在程序执行前！程序会先将所有var 声明的变量和function声明的函数 提前到当前作用域的顶部集中创建 而(赋值=)留在原地")]),a._v(" "),n("p",[a._v("所以声明提前是js广受诟病的缺陷")]),a._v(" "),n("p",[a._v("打乱了程序正常执行的顺序")]),a._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[n("p",[a._v("new 来创建")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(' var fun = new Function("形参1","形参2")\n')])])])])]),a._v(" "),n("p",[a._v("2 赋值方式创建：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      var 函数名 = function(形参列表){\n          函数体\n      }\n\n说明: 赋值方式创建的函数 和声明方式 创建的函数在使用时 都一样\n只不过 在程序开始执行前 赋值方式可避免函数被声明提前 保持了程序原有的执行顺序\n\n揭示: js中其实函数也是一个普通的对象而已,函数名仅仅是一个普通的变量 函数名变量通过对象地址引用着函数对象,每次调用函数名时 通过地址 找到函数对象 再执行其中内容\n\n变量 : 内存中存储一个数据的存储空间 在起一个名字\n")])])]),n("p",[a._v("强调 如果一个函数 只是定义 没有调用 该函数体是不会执行")]),a._v(" "),n("p",[a._v('global["a"];  底层  关联数组')]),a._v(" "),n("h3",{attrs:{id:"重载-overload"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#重载-overload"}},[a._v("#")]),a._v(" 重载(overload)")]),a._v(" "),n("h2",{attrs:{id:"什么是-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是-2"}},[a._v("#")]),a._v(" 什么是:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  多个同名函数 不同形参列表 在调用时根据传入实参列表的不同 动态选择函数执行 \n")])])]),n("h2",{attrs:{id:"为什么-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么-2"}},[a._v("#")]),a._v(" 为什么")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  减少函数个数 减轻调用者的负担\n")])])]),n("h2",{attrs:{id:"何时"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#何时"}},[a._v("#")]),a._v(" 何时")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  只要一件事 可能根据传入参数的不同  执行不同的逻辑 都要使用重载！\n")])])]),n("h2",{attrs:{id:"如何"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何"}},[a._v("#")]),a._v(" 如何:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  问题Js不支持标准的重载写法 因为js不允许多个同名函数的存在！\n")])])]),n("h2",{attrs:{id:"解决"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解决"}},[a._v("#")]),a._v(" 解决:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    js中借助于arguments 对象实现重载\n")])])]),n("h2",{attrs:{id:"什么是-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是-3"}},[a._v("#")]),a._v(" 什么是:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    每个函数内自带的 专门接收所有传入函数的实参值列表的数组对象。\n\n函数内自带对象 不用创建可直接拿来使用 接收所有传入函数的实参值 即使没有定义形参变量 或形参变量个数少于传入实参值个数 都没关系\n\narguments 可接住所有传入函数的实参值 这就是为什么js 中的函数 定义了几个形参和调用了几个实参 毫无关系\n")])])]),n("h1",{attrs:{id:"类数组对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类数组对象"}},[a._v("#")]),a._v(" 类数组对象:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("长得像数组的对象\n  像数组 1 小标 2 length\n  不是数组 是对象 不是数组家孩子\n")])])]),n("h2",{attrs:{id:"何时-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#何时-2"}},[a._v("#")]),a._v(" 何时:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  只要js中接收不确定个数的参数值 都用arguments.\n")])])]),n("h2",{attrs:{id:"如何-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何-2"}},[a._v("#")]),a._v(" 如何:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  1 无论传入多少个参数 都只定义一个函数 \n  2 在函数内直接访问 arguments 根据 arguments 不同 动态选择不同的逻辑执行任务。\n")])])]),n("p",[a._v("如果只是部分参数不确定 而且参数赋值给参数时 又要求对应关系怎么办？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('    cook(,,"面")\n')])])]),n("p",[a._v("答: 以上传参方式 会报语法错误！因为实参列表不允许出现空值")]),a._v(" "),n("h3",{attrs:{id:"当遇到多个参数不确定有没有-又要要求对应关系时-只能使用对象语法解决"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#当遇到多个参数不确定有没有-又要要求对应关系时-只能使用对象语法解决"}},[a._v("#")]),a._v(" 当遇到多个参数不确定有没有 又要要求对应关系时 只能使用对象语法解决")]),a._v(" "),n("p",[a._v("2 步")]),a._v(" "),n("p",[a._v("1 定义函数时:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      function 函数(形参列表变量){\n        // 先判断 obj 对象包含那些属性 不包含那些属性 缺少的属性用默认值代替\n        // 函数执行过程中 都从对象里,取实参值使用！\n      } \n      \n      但是, 我们规定 在将来调用时 实参值都要放在一个对象中传入\n")])])]),n("p",[a._v("2  调用函数时:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("            函数名({属性1:实参值1，,属性2:实参值2...});\n")])])]),n("h2",{attrs:{id:"优点-任意参数都可以缺少-都不会报错"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优点-任意参数都可以缺少-都不会报错"}},[a._v("#")]),a._v(" 优点: 任意参数都可以缺少 都不会报错")]),a._v(" "),n("p",[a._v("1 Test\n任意参数求和")]),a._v(" "),n("h2",{attrs:{id:"匿名函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#匿名函数"}},[a._v("#")]),a._v(" 匿名函数")]),a._v(" "),n("p",[a._v("什么是：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    定义函数时 不被任何变量所引用的函数  \n      (function(){}());\n")])])]),n("p",[a._v("为什么： 1 为了节约内存 2 划分临时作用域！")]),a._v(" "),n("p",[a._v("何时：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    1. 如果一个函数只执行一次 \n    2. 划分临时作用域！\n")])])]),n("p",[a._v("如何:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    1. 回调函数: 今后大多为匿名函数\n    2. 匿名函数自调\n    1. 为什么  全局变量 极易被污染！ 今后禁止使用全局变量 !\n")])])]),n("p",[a._v("匿名函数自调 定义函数后 立即调用函数 调用后立即释放！")]),a._v(" "),n("p",[a._v("问题 全局变量极易被污染！又不会自动释放 所以 今后禁止使用全局变量")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("解决 今后js 代码 都要包裹在匿名函数自调用中 \n好处 绝对不会产生全局变量 节约内存又不影响功能执行\n")])])]),n("h1",{attrs:{id:"作用域和作用域链"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#作用域和作用域链"}},[a._v("#")]),a._v(" 作用域和作用域链")]),a._v(" "),n("h2",{attrs:{id:"作用域-scope"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#作用域-scope"}},[a._v("#")]),a._v(" 作用域(scope):")]),a._v(" "),n("p",[a._v("什么是")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("用途: 作用域就是一个变量的可用范围\n本质：作用域是保存变量的一个对象\n为什么： 为了避免不同范围得变量互相干扰!\n包括 JS中只包括2级作用域\n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​        1. 全局作用域：\n​"),n("br"),a._v("\n1. 保存任何地方都可以访问到的变量区域\n2. 全局中保存的变量称为全局变量\n3. 全局变量优点 共用 可反复使用\n4. 缺点 易被污染 浪费内存")]),a._v(" "),n("p",[a._v("​"),n("br"),a._v("\n​        2. 函数作用域\n​                1. 保存在函数内才可以使用的变量区域\n​                2. 函数作用域中保存的变量是局部变量\n​                3. 局部变量优点 仅函数内可用 不会污染全局且用完就释放  不占用内存\n​                4. 缺点 无法重用！")]),a._v(" "),n("h2",{attrs:{id:"程序和函数的执行过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#程序和函数的执行过程"}},[a._v("#")]),a._v(" 程序和函数的执行过程：")]),a._v(" "),n("p",[a._v("1.当程序执行时 先创建全局作用域对象window")]),a._v(" "),n("p",[a._v("在window中 先保存所有的全局变量 和全局 函数")]),a._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[n("p",[a._v("当定义函数时 每个函数其实都有一个好友列表 暂时包含两项 离自己最近的一项是暂时是空的  距离自己远一些的一项保存着指向window 对象的地址")])]),a._v(" "),n("li",[n("p",[a._v('"好友列表"作用是 将来调用函数时,万一缺变量,可按照好友列表的顺序 去朋友中寻找')])])]),a._v(" "),n("p",[a._v("当调用函数时 会临时创建这次调用函数的函数作用域对象 并在函数作用域对象中添加函数的局部变量 并将函数作用域对象的引用 假如函数的好友列表中最近的一项保存！说明函数和临时创建的函数作用域对象 关系最好！ 缺变量 先找临时创建的函数作用域对象  如果函数作用域对象没有 才被迫找window要")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("当函数调用后 临时创建的函数作用域对象被释放 函数作用域对象中的变量同时释放 —————— 这就是为什么局部变量不可重用 的原因！！！\n")])])]),n("h2",{attrs:{id:"作用域链-scopes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#作用域链-scopes"}},[a._v("#")]),a._v(" 作用域链(scopes)")]),a._v(" "),n("p",[a._v("什么是:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("一个函数可用的所有作用域对象的集合。\n")])])]),n("p",[a._v("普通函数的作用链 在调用时是两个成员")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    1. 距离自己最近的是临时创建的函数作用域对象\n    2.  离自己稍微远一些的是全局作用域对象 window\n")])])]),n("p",[a._v("一个函数的作用域链")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("         1.  保存着这个函数可用的所有变量\n         2.  控制这变量的使用顺序\n             \n             先局部 后全局\n")])])]),n("h1",{attrs:{id:"闭包-closure"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#闭包-closure"}},[a._v("#")]),a._v(" 闭包(closure)")]),a._v(" "),n("h2",{attrs:{id:"什么是闭包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是闭包"}},[a._v("#")]),a._v(" 什么是闭包：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("用途: \n\n  既重用一个变量 有保护这个变量不被污染的一种编程方法\n\n本质: \n    \n    外层函数的作用域对象 被内层函数对象引用着 无法释放  这个外层函数的作用域就是闭包对象\n\n为什么: \n\n    全局变量和局部变量的优缺点\n    全局变量: 优点 可重用 缺点 极易被污染！;\n    局部变量：优点  不会被污染 缺点:不可重用！;\n")])])]),n("p",[a._v("何时：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  今后 只要为一个函数保存一个专属的 可重用的 还不会被外部污染的变量\n")])])]),n("p",[a._v("如何：4步")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("        1. 外层函数包裹要保护的变量和内层函数\n           内层函数一定要使用了外层函数的局部变量\n        2. 外层函数将内层函数抛到外部\n        3. 调用者调用外层函数 获得返回的内层函数对象 保存在变量中。 并反复使用。\n        4. 外层定义一个变量接收return出的参数\n")])])]),n("p",[a._v("闭包是如何形成的")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  外层函数作用域对象,被内层函数对象引用着无法释放\n")])])]),n("p",[a._v("闭包的缺点")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("1. 比普通函数占用更多内存\n2. 多占用父母函数作用域对象\n3. 闭包不会自动释放 可能造成内存泄漏\n")])])]),n("p",[a._v("解决: 使用完闭包后 如果不在使用了 要手动释放闭包\npay = null")]),a._v(" "),n("p",[a._v("定义一个取号机函数 getNum() 可反复输出一个递增的不重复的数字")]),a._v(" "),n("p",[a._v("var getNum()\ngetNum();//1\ngetNum();//2\n//试图用同名变量篡改序号为0\nxxx=0;\ngetNum();//3")]),a._v(" "),n("p",[a._v("function fun(){\nvar n = 999\nnAdd = function(){n++}\nreturn function(){\nconsole.log(n)\n}\n}\nvar getN = fun();\ngetN();//?\nnAdd();\ngetN();//?")]),a._v(" "),n("hr"),a._v(" "),n("h1",{attrs:{id:"面向对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[a._v("#")]),a._v(" 面向对象")]),a._v(" "),n("p",[a._v("什么是对象:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("用途: 对象是描述现实中一个具体事物的属性和功能的程序结构\n\n本质： 程序中集中存储一个事物的属性和功能的一块存储空间 再起一个名字\n")])])]),n("p",[a._v("为什么：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  便于大量数据的维护和使用\n")])])]),n("p",[a._v("什么是面向对象编程：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  程序都是先将数据封装在对象中 然后再按需使用对象中的成员。 这样的编程方式 就是面向的对象编程\n")])])]),n("p",[a._v("何时:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  今后所有程序都是用面向对象方式实现的\n")])])]),n("p",[a._v("如何：\n面向对象三步/三大特点: 封装 继承 多态")]),a._v(" "),n("h1",{attrs:{id:"封装-继承-多态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#封装-继承-多态"}},[a._v("#")]),a._v(" 封装 继承 多态")]),a._v(" "),n("h2",{attrs:{id:"封装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[a._v("#")]),a._v(" 封装：")]),a._v(" "),n("p",[a._v("什么是：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  创建一个对象 集中保存一个事物的属性和功能\n")])])]),n("p",[a._v("何时：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  - 只要使用面向对象方式编程 都要先将数据和功能封装在对象中 然后再按需使用。\n")])])]),n("p",[a._v("如何3种：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      1.用{} 创建一个对象\n            \n                  var 对象名={\n                      属性名:值,\n                      ....\n                      方法:function(){\n                        \n                      }\n                  }\n")])])]),n("p",[a._v("如何访问")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      对象名.属性名\n      对象名.方法(){}   \n")])])]),n("p",[a._v("问题：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  在对象自己的方法 直接使用属性名却无法访问到自己的属性 报错 属性名未定义\n")])])]),n("p",[a._v("原因")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  所有不带.的变量,默认只能在作用域链中(临时函数作用域和我window)查找。 但是对象中{}又不是作用域 所以对象是不包含在作用域链中的 所以直接使用属性,无法找到藏在对象内的属性的。 不好的解决方法：在属性名前加对象. ,勾引着引擎进入对象中查找属性。\n")])])]),n("p",[a._v("问题：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    紧耦合 如果外部修改 内部被迫跟着修改\n")])])]),n("p",[a._v("解决:\n松耦合 外部改变 内部d代码不用改变 也能自动适应")]),a._v(" "),n("h1",{attrs:{id:"this-属性名"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this-属性名"}},[a._v("#")]),a._v(" ———— this.属性名")]),a._v(" "),n("h2",{attrs:{id:"什么是this"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是this"}},[a._v("#")]),a._v(" 什么是this:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  在调用函数时 临时指向正在调用函数的.前对象的关键词\n\n  总结 只要是自己的方法 想访问自己的属性就使用this\n")])])]),n("p",[a._v("错误：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("函数定义在哪个对象中 this就指向哪个对象 \n")])])]),n("p",[a._v("正确：\nthis与函数定义在哪无关！只与函数调用这一瞬间.前对象有关")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    2.   用new创建：2步\n            1.   先创建空对象 var obj = new Object();\n            2.  强行向空对象中添加新属性  \n                1.  obj.属性 = 值\n                2.  obj.方法 = function(){...}\n            揭示： 所有js对象底层 都是关联数组。\n")])])]),n("h1",{attrs:{id:"对象-vs-关联数组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对象-vs-关联数组"}},[a._v("#")]),a._v(" 对象 VS 关联数组")]),a._v(" "),n("h2",{attrs:{id:"相同-4-个"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#相同-4-个"}},[a._v("#")]),a._v(" 相同 4 个")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('            1. 都可以用["成员名"]或.成员名两种方式 访问自己的成员。 .成员名 其实就是["成员名"] 简写 也就是说 .成员名 到底层会被自动翻译成["成员名"]\n            \n            坑 如果成员名来自于一个变量！ 则不能用".变量"方式访问成员。因为."变量" 会被翻译为["变量"], 出错了 因为变量不可以放在""里！\n            解决: 今后只要成员名不是写死的，而是来自于一个变量 只能用[变量], 不带引号的方式访问\n\n            2. 都可以被for in循环遍历每个成员\n            \n            3.  随时可以给数组或对象在任何位置添加新成员,而不会报错！ 而自动创建该成员\n              所以 如果想给一个已创建玩得对象 添加新属性 只有一个野蛮的办法 强行赋值！\n\n            4.  访问数组或对象中不存在的位置 不会报错 而是返回undefined！\n\n              不同 类型\n                    关联数组: 是数组家的孩子\n                    对象 是object 孩子\n')])])]),n("p",[a._v("问题:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  只能创建一个对象 如果反复创建 多个相同结构的对象时。\n  代码很冗余 不便于维护。\n")])])]),n("p",[a._v("解决:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("用构造函数：\n什么是： 专门描述一类对象统一结构的函数\n为什么:  为了重用对象的结构定义 \n何时： 只要程序中需要反复创建 同一类型的多个对象时。\n")])])]),n("h1",{attrs:{id:"构造函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[a._v("#")]),a._v(" 构造函数")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  如何: 2步\n    1. 定义构造函数来描述一类对象同意结构\n        function 类型名(形参1){\n          this.属性名 = 形参1;\n          this.属性名...形参1;\n          this.方法=function(){}\n        }\n    2. 调用构造函数按照统一结构创建对象  \n        var obj = new 类型名(属性值1,);   \n        new 的 原理：4件事;\n            1. 新建一个空对象\n            2. ？\n            3. 用new调用构造函数 将构造函数中的this 都吸引到new上!\n              然后通过强行赋 \n      问题：构造函数虽然实现了代码重用,但是浪费了内存！\n")])])]),n("h1",{attrs:{id:"继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[a._v("#")]),a._v(" 继承")]),a._v(" "),n("p",[a._v("什么是: 爹的成员 孩子无需重复创建,可直接使用")]),a._v(" "),n("p",[a._v("为什么: 代码重用, 节约内存")]),a._v(" "),n("p",[a._v("何时：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    只要多个孩子都需要共用的成员,都通过继承使用！\n")])])]),n("p",[a._v("如何：\n不用自己设置继承关系！其实js中已经帮我们设置好了继承关系")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  我们直接使用即可！\n           \n           1. js实现继承, 都是通过继承原型对象来实现的\n              原型对象：专门集中保存一类对象的共有成员的父对象。\n\n              原型对象是在定义构造函数时,附赠的。只不过暂时是空的\n              如何找到原型对象: 每个构造函数都有一个prototype 指向自己附赠的这个原型对象\n              其实 原型对象中 也有一个constructor属性 指回构造函数\n\n              子对象如何继承父对象:\n              new 的 第2步：让子对象的__proto__属性指向妈妈的原型对象 凡是从__proto__属性值指出的关系,都叫继承关系。\n        \n        结果： 原型对象中的成员 子对象无需创建 可直接使用！\n")])])]),n("p",[a._v("如何向原型对象中添加共有成员:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    妈妈.prototype.成员名=值\n    比如 向所有学生的共同的爸爸 里强行添加一个公用的方法 intrSelf()\n    Student.prototype.intrSelf = function(){\n      .... .....\n    }\n    结果： 凡是 Student 生的孩子 都能.inerSelf()来直接调用爹的函数\n      比如  lilei.intrSelf();\n    \n    妈妈叫爸爸 prototype\n    孩子叫爸爸  __proto__ \n")])])]),n("p",[a._v("​")]),a._v(" "),n("h2",{attrs:{id:"自有属性-和-共有属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自有属性-和-共有属性"}},[a._v("#")]),a._v(" 自有属性 和 共有属性：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("       自有属性：保存在子对象中 归对象个人所以有的属性\n\n       共有属性：保存在原型对象中,归于多个子对象共有的属性\n")])])]),n("p",[a._v("获取属性值： 二者没有任何差别  子对象.属性名")]),a._v(" "),n("p",[a._v("修改属性值:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("          自有属性,可直接用子对象修改\n          比如 lilei.sage++;\n          \n          共有属性,只能用原型对象修改\n          如果强行用子对象.共有属性修改 \n          会给这个子对象添加一个同名的自有属性。 从此这个子对象和父对象的属性无关了\n")])])]),n("h2",{attrs:{id:"内置对象的原型对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内置对象的原型对象"}},[a._v("#")]),a._v(" 内置对象的原型对象:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      任何一种类型 其实都是由构造函数和原型对象组成。内置类型也是这样。\n      Js包括的那些内置类型：\n          String Number Boolean\n          Array  Date  Math RegExp  Error  Function  Object \n          global  \n")])])]),n("p",[a._v("​")]),a._v(" "),n("h2",{attrs:{id:"所有内置类型也包含构造函数和原型对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#所有内置类型也包含构造函数和原型对象"}},[a._v("#")]),a._v(" 所有内置类型也包含构造函数和原型对象：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      构造函数: 创建该类型的子对象\n      原型对象：保存该类型的所有子对象共有的方法和属性\n")])])]),n("p",[a._v("比如: Array 类型就包含2部分")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("1.数组类型构造函数:\n        function Array(){...}\n        所以创建数组可以使用new Array()\n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​    2 数组类型也有一个原型对象 包含所有数组对象公用的函数:\n​            为一个类型添加一个共有的自定义函数;\n​            何时: 只要项目中 经常对一个类型的对象做一种操作 而这个类型的原型对象中又不包含这种函数。\n​"),n("br"),a._v("\n如何: 比如:为所有数组添加求和这种函数\nsum\n1 在数组类型的原型对象中添加sum函数\n2 用数组类型的子对象 调用这个sum")]),a._v(" "),n("h1",{attrs:{id:"面向对象-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#面向对象-2"}},[a._v("#")]),a._v(" 面向对象")]),a._v(" "),n("h2",{attrs:{id:"继承-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#继承-2"}},[a._v("#")]),a._v(" 继承:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  原型链\n        \n    什么是: 由多级父对象 逐级继承 形成链式结果\n        作用：\n         \n          1. 保存了一个对象可用的所有成员 \n             将来判断一个对象可以使用那些成员,就看它的原型链\n             上有什么成员\n            \n             如果一个成员在子对象的原型链的某个父级对象上 就可以:子对象.成员  访问\n            \n             如果一个成员不包含在子对象的原型链的任意一个对象上,就不能用 子对象.成员访问\n          \n          2. 控制着成员的使用顺序:\n              先自有 再共有！\n")])])]),n("h1",{attrs:{id:"多态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[a._v("#")]),a._v(" 多态")]),a._v(" "),n("p",[a._v("什么是:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  一个函数,在不同情况下表现出不同的状态\n")])])]),n("p",[a._v("包括:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    1.  重载: 根据传入参数的\n    2.  重写:\n         \n      什么是: 在子对象中定义和父对象中成员完全相同的成员 来覆盖父对象的成员  \n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​          为什么: 从爹继承来的成员不一定都是好用的！")]),a._v(" "),n("p",[a._v("​"),n("br"),a._v("\n​          何时：只要子对象觉得从爹继承来的不好用就要重写！\n​             如何：只要在子对象中定义和父对象同名的成员")]),a._v(" "),n("p",[a._v("console.dir()  //输出对象的存储结构")]),a._v(" "),n("h2",{attrs:{id:"自定义继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自定义继承"}},[a._v("#")]),a._v(" 自定义继承:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    何时: 只要觉得现在的爹不好用！就可以用\n    如何:\n        \n        1. 只更换一个对象的爹\n            \n            子对象__proto__=新爹\n            \n            问题:__proto__浏览器不推介使用\n            \n            解决:setPrototypeOf()代替__prpto__ \n            Object.setPrototypeOf(子元素,新爹)\n     \n  set        of Prototype\n  \n  设置子元素  的 原型对象 为 新爹\n  Object.setPrototypeOf(hmm,father);\n     \n        2. 同时多个对象的爹\n            构造函数.prototype=新老公\n            时机: 在创建子对象之前换\n")])])]),n("h1",{attrs:{id:"es5"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es5"}},[a._v("#")]),a._v(" ES5")]),a._v(" "),n("p",[a._v("什么是:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("EMAScript 标准的第五个升级版本\n")])])]),n("p",[a._v("为什么:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" 因为Js这门语言 又很多广受诟病的缺陷\n")])])]),n("p",[a._v("包括哪些新的规则:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('  "use strict"\n')])])]),n("p",[a._v("严格模式:")]),a._v(" "),n("p",[a._v("什么是:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  比普通Js运行要求更严格的机制\n")])])]),n("p",[a._v("为什么:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  因为Js这门语言 又很多广受诟病的缺陷\n")])])]),n("p",[a._v("何时：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  今后所有Js程序都要在严格模式下！\n          \n          严格模式的新需求: \n          \n          1. 禁止给未声明变量赋值！\n                旧Js 强行给未声明的变量赋值 \n            结果: 会自动在全局创建\n                  全局污染 内存泄漏\n          \n            严格Js中 强行给未声明的变量赋值\n            结果: 报错:xxx is not undefined!\n            避免内存泄漏和全局污染\n\n         2. 静默失败升级为错误\n               静默失败:执行不成功 也不报错！\n                   极其不便调试\n             严格模式中:静默失败 也会报错！    便于调试\n         \n         3. 普通函数调用和匿名函数自调中的this不再默认指向window 而是指向undefined\n         防止全局污染 内存泄漏  \n\n         4. 禁止使用 arguments.callee\n              \n            什么是 arguments.callee: 是函数运行时, 专门获得当前正在执行的函数本身。\n          \n            何时: 递归！        \n              为什么:避免紧耦合 避免在函数内写死函数名。\n\n\n\n    问题: 递归效率极低！———— 重复计算量太大\n\n\n\n    所以 Es5 严格模式 出于性能考虑 禁用了 arguments.callee 就暗示不推介使用递归算法。\n\n\n\n    解决：绝大多数的递归可以找循环代替\n\n    为什么:避免紧耦合 避免在函数内写死函数名。\n\n\n\n    问题: 递归效率极低！———— 重复计算量太大\n\n    所以 Es5 严格模式 出于性能考虑 禁用了 arguments.callee 就暗示不推介使用递归算法。\n\n\n    解决：绝大多数的递归可以找循环代替\n")])])]),n("h2",{attrs:{id:"保护对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#保护对象"}},[a._v("#")]),a._v(" 保护对象:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('    什么是:\n        \n        控制对象的属性值或对象结构进行的随意篡改\n    \n    为什么: \n    \n        在旧的Js中 对象的属性和结构毫无自保能力。 任何人可在任何时候修改属性值为任何值 也可以随意添加属性和删除属性\n   \n     何时: \n     \n     \t需要控制对对象的访问时\n\n  如何：2个层面:        \n\n\n\n    \n\n1 保护对象的属性\nES5对对象的属性进行了重新分类\n        命名属性: 可用.访问到属性\n            又分为:\n                数据属性 实际存储属性值的属性。\n       \n                访问器属性 不实际存储属性值,仅提供对另一个数据属性的保护。\n                \n        内部属性： 无法用.访问到内部的属性\n        \n        如何保护数据属性：\n            旧js中 数据属性其实就是一个普通的变量 毫无自保能力\n        \n            ES5 标准中: 每个数据属性都是一个缩微的小对象。 每个小对象中,保存一个属性和三个开关\n\n            如何修改属性的小开关来保护一个属性呢\n        \n            问题: 不能用.直接修改属性对象内部的开关属性！\n\n      解决：必须用专用的函数解决\n    \n            Object.defineProperty(\n                对象名,\n                "属性名",\n                {\n                  开关：true/false\n                }\n            )\n    \n    问题:writable和enumerable两个开关,任何人都可以随意开关。所以设置这两个起不到保护作用。\n')])])]),n("p",[a._v("​"),n("br"),a._v("\n​        解决:  只要设置 writeble 和 enumerable\n​"),n("br"),a._v("\n都要同时关闭configurable, 目的是禁止修改前两个开关")]),a._v(" "),n("p",[a._v("解决:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("   只要设置writable 和 enumerable 都要同时关闭configurable 目的是禁止修改两个开关。 且\n")])])]),n("h2",{attrs:{id:"configurable一旦被改为fals-不可逆"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#configurable一旦被改为fals-不可逆"}},[a._v("#")]),a._v(" configurable一旦被改为fals 不可逆！")]),a._v(" "),n("p",[a._v("问题:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("   enumerable 只能禁止for in 遍历这个属性 无法阻止用.直接访问这个属性。———— 这是半隐藏 \n  解决： 无法解决\n  问题： Object.defineProperty()一次只能修改对象中的一个属性。如果外部修改多个属性 就要重复写多遍\n  \n  解决\n  Object.defineProperties(\n      对象名,{\n        属性名:{\n          开关：true/false\n        },....\n      }\n  )\n\n问题: 使用保护属性 规则单调 无法使用自定规则保护属性\n")])])]),n("p",[a._v("解决:使用访问器属性保护数据属性")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      什么是访问器属性 自己不保存数据,专门提供对其他数据属性的保护。\n")])])]),n("p",[a._v("何时：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("        只要使用灵活的自定义规则保护数据时 就会要请保镖！\n")])])]),n("p",[a._v("如何:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      0. 先将要保护的数据属性  隐形埋名, 并且半隐藏！！\n      1. 为对象添加访问器属性,保护属性\n         \n          1 访问器属性要冒名顶替使用原属性名\n          2 访问器属性中包含get set两个属性值\n          \n          get 负责读取受保护的属性值\n          set 中负责先验证再修改受保护的属性值\n          \n          访问器属性不再需要value和writable。 但是需要设置enumerable 和 configurable\n")])])]),n("p",[a._v("访问器属性如何发挥作用:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      因为访问器属性是冒名顶替的所以,外人访问器属性时 和 访问普通属性是一样的\n      \n      只不过访问器属性执行时, 会自动根据外人做到的操作,来选择get和set 来调用 \n")])])]),n("h1",{attrs:{id:"es5-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es5-2"}},[a._v("#")]),a._v(" ES5")]),a._v(" "),n("p",[a._v("保护对象")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("保护对象的属性:\n\n保护对象的结构: 3 个级别\n      1. 禁止添加新属性:\n                Object.preventExtensions(obj);\n      \n            阻止对obj对象添加任何扩展属性 \n            原理 每个对象都有一个隐藏的\n            \n            extensible的属性默认值为true\n            preventExtensions(obj)使这个内部隐藏属性改为false\n      \n      2. 密封：在兼具防扩展的基础上 进一步禁止删除现有属性\n          Object.seal(obj);\n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​    2 件事\n​        1. 禁止添加新属性\n​          Object的extensible = false\n​"),n("br"),a._v("\n2. 禁止删除现有属性\n自动将所有属性的configurable 都改为false！ 从此defineProperties中不需要再重复写 configirable:false!\n其实今后 大多数对象都要密封！\n强调： 虽然密封禁止修改结构 但是属性值随便改！")]),a._v(" "),n("p",[a._v("​"),n("br"),a._v("\n​     3. 冻结： 在兼具密封的基础上 进一步禁止删除现有属性 禁止修改属性值！\n​        Object.freesze(obj)")]),a._v(" "),n("p",[a._v("​"),n("br"),a._v("\n​      3 件事:\n​"),n("br"),a._v("\n1. 禁止添加新属性")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("              obj的extensidle=false\n      \n      2. 禁止删除现有属性:\n        \n          自动 将所有的属性的configurable都改为false！\n      \n      3. 自动将所有属性的writable都改为false。\n")])])]),n("h2",{attrs:{id:"object-create"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#object-create"}},[a._v("#")]),a._v(" Object.create()")]),a._v(" "),n("p",[a._v("函数:没有构造函数的情况下，也想到创建一个子对象    子对象继承的简单写法")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("3 件事:  \n        1.创建一个新对象\n        2. 继承一个父对象\n        3. 为新对象添加自有属性\n       \nvar 子对象 =  Object.create(父对象,{\n        // defineProperties\n        属性名:{\n          value : 属性值,\n          writable:true/false,\n          enumerable: true/false,\n          configurable : true/false\n        }\n        ......\n}) \n")])])]),n("h2",{attrs:{id:"call-apply-bind-替换this"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#call-apply-bind-替换this"}},[a._v("#")]),a._v(" call,apply,bind: 替换this")]),a._v(" "),n("p",[a._v("何时:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  只要函数执行时 内部this 不是我们想要的\n  就可以使用这三个函数 将不想要的this换成任意一个想要的对象。\n")])])]),n("p",[a._v("如何：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  1. call,apply: 在一次调用函数时，临时替换一次this！\n        要调用的函数.call(替换this的对象，...)\n        强调: 实参值列表必须从第二个值开始。\n        因为第一个实参的位置让给了替换this的对象！\n  原理: \n        call 更大的作用：可让任何对象去调用原本没有任何关系的一个函数。 —————— 抢\n")])])]),n("h2",{attrs:{id:"apply-vs-call"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#apply-vs-call"}},[a._v("#")]),a._v(" apply vs call:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    apply 和 call 用法几乎完全一样。只不过,要求所有的实参值都要放在一个数组中整体传入。\n\n    执行过程：\n      1. 先用第一个参数值对象替换函数中的不想要的this。\n      2. 打散数组为多个单独的元素值，分别传给对应的每个形参变量\n\n    总结：通常情况下 要替换函数中的this,用call就够了！ 只有实参值类表是放在一个数组中的时候才需要使用apply 先打散再传入函数。\n")])])]),n("h2",{attrs:{id:"bind"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bind"}},[a._v("#")]),a._v(" bind")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("bind: 不调用函数,而是基于函数,创建一个新函数副本。并永久替换新函数中的this为指定的对象。\n")])])]),n("p",[a._v("何时:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  今后,如果一个函数需要反复调用，又反复替换其中的this时 都是用 bind() 来创建副本,\n                  并永久绑定this\n")])])]),n("p",[a._v("如何:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      var 新函数 = 旧函数.bind(\n          替换this的对象,\n          要绑定的实参值,\n          ....                                  \n      )\n")])])]),n("p",[a._v("结果:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("1. 新函数的功能和就函数是完全一样的。\n2. 但是新函数中的this和开头部分形参,已被永久替换为固定的对象和固定的参数值。\n3. 今后调用新函数时,只要传入可能变化的剩余几个实参值即可！\n")])])]),n("h1",{attrs:{id:"数组函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组函数"}},[a._v("#")]),a._v(" 数组函数")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('1.数组中查找元素: indexOf \n  \n  数组中的indexOf 和字符串的 indexOf 完全一样\n  var i = arr.indexOf("元素",fromi);\n  在arr数组中 从 fromi位置开始 找下一个和指定"元素"相同的元素所在的位置i\n      返回值:如果找到 返回 i\n              如果没有找到 返回-1\n')])])]),n("p",[a._v("判断:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("1. 判断数组中是否所有元素都符合要求\n      var bool = arr.every(function(value,i,arr){\n        //value 当前元素值\n        // i 当前索引位置\n        // arr 当前数组元素\n        return 判断条件;\n      })\n          \n原理 every 会自动遍历arr中的每个元素。\n  \n每遍历一个元素,就会自动调用一次回调函数function。\n\n每次调用function时,自动传入当前正在遍历的元素值和下标位置,以及当前数组对象,每次调function 都会用函数内的条件检查当前元素会否符合要求 \n\n只有当前元素符合要求 才能继续遍历下一个元素。 只要碰一个不符合要求的元素,就立刻退出遍历 返回false。意思是不是所有元素都满足要求。\n如果遍历结束,还没有退出,说明整个数组中都符合要求 整个every(),就返回true\narr[i+1]\n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​    2. 判断数组中是否包含符合要求的元素\n​          var bool =arr.some(function(value,i,arr ){\n​                return 判断条件\n​          });")]),a._v(" "),n("p",[a._v("​"),n("br"),a._v("\n​        用法和every完全相同 只不过执行时 只要碰到一个元素判断为true  就不不再遍历,直接返回true。 只有遍历结束 还没有找到判断为true才返回false;")]),a._v(" "),n("p",[a._v("​")]),a._v(" "),n("h2",{attrs:{id:"遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#遍历"}},[a._v("#")]),a._v(" 遍历")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    普通遍历: 代替for循环\n        for(var i=0;i<arr.length;i++){\n              //i  当前位置 // arr[i] 当前元素值 \n        }\n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​"),n("br"),a._v("\n​            arr.forEach(function(value,i,arr){\n​                  //对当前元素执行的操作！\n​            })")]),a._v(" "),n("p",[a._v("​"),n("br"),a._v("\n​            forEach中自动遍历arr中的每个元素 每遍历一个元素 就在这个元素上自动调用一次回调函数function 自动传入当前元素值给value 当前位置给i 当前数组对象给arr。")]),a._v(" "),n("p",[a._v("​"),n("br"),a._v("\n​      遍历并复制原数组为新数组\n​              var 新数组=原数组.map(\n​                // var newArr=[];//自动\n​                // for(var i=0; i<arr.length;i++){}\n​                //      arr[i] i this\n​                //          ↓  ↓  ↓\n​                function(value,i,arr){\n​                  return 要放入的新数组中的元素值\n​                }\n​                //return newArr;//自动\n​              )\n​        原理:\n​"),n("br"),a._v("\n1. map 内先自动创建一个新数组")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("        2. 然后才是带着回调函数一起遍历 原数组.自动将回调函数在每个元素上执行一次 将回调函数return的结果 放到新的数组中相同的位置上\n        \n        3. 遍历结束 返回新数组\n    总结:\n      \n      1. 仅单纯代替 for 循环遍历数组,首选foreach\n      \n      2. 除非想保护原数组,返回的新数组时 采用map. \n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​      过滤和汇总：\n​"),n("br"),a._v("\n1. 过滤: 复制出原数组中符合条件的元素组成 新数组返回. 原数组保持不变！")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("              var 新数组=原数组.filter(\n                function(value,i,arr){\n                  return 判断条件\n                }\n              ) \n              \n    原理:\n        \n        1.先创建一个空数组\n        \n        2.自动遍历原数组中每个元素 每遍历一个元素 就自动调用一次回调函数 如果当前元素经过回调函数验证,返回true 则加入新数组中 如果当前元素经过回调函数验证 返回false 则不加入新数组.  \n        \n        3. 遍历结束,返回新数组！\n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​            2. 汇总： 对数组中的元素内同容进行统计 得出最终结论")]),a._v(" "),n("p",[a._v("​"),n("br"),a._v("\n​"),n("br"),a._v("\n​"),n("br"),a._v("\n//作业\n1 如何用ES5实现两种类型的继承 ———— 手写\n2 如何 判断一个对象是不是数组 共有几种方法！ 6种以上")]),a._v(" "),n("h1",{attrs:{id:"es6"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[a._v("#")]),a._v(" ES6")]),a._v(" "),n("h2",{attrs:{id:"什么是-ecmascript-第6个版本"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是-ecmascript-第6个版本"}},[a._v("#")]),a._v(" 什么是:ECMAScript 第6个版本")]),a._v(" "),n("p",[a._v("优点: 在不改变原理的基础上 简化了Js代码")]),a._v(" "),n("p",[a._v("问题: 兼容性")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  包括:\n\n      let:\n          什么是:  专门代替var 来声明变量用\n         \n          为什么:  var 的问题:\n              1. 声明提前\n              2. 没有块级作用域\n         \n          何时: 只要声明变量都用 let\n         \n              优点：\n                  1.阻止了声明提前\n                  1. 添加块级作用域\n         \n          原理: let 其实就是一个匿名自调!\n                且let 为了双保险 其实底层悄悄给变量改了名字\n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​              let 小脾气\n​                  1 在相同作用域/块内，禁止同时let两个同名的变量\n​"),n("br"),a._v("\n2 在let a之前到当前作用域顶不允许提前使用 a 变量")]),a._v(" "),n("h2",{attrs:{id:"箭头函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[a._v("#")]),a._v(" 箭头函数:")]),a._v(" "),n("p",[a._v("什么是  对普通函数声明的简写")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('      何时： 今后绝大多数匿名函数的创建 都用箭头函数。\n\n          如何 3件事\n\n              1 去掉 function 在()和{}之间=>\n              \n              2 如果形参列表只有一个变量 可省略()\n              \n              3 如果函数体只有一句话 可省略{}\n              但是 如果仅有的这句话 还是return 则必须省略return\n              去掉{}时 还要注意去掉语句结尾";"\n\n        双刃剑\n            \n            让函数内外this连通 保持一致。都指向函数外this\n        \n        结论: 如果希望函数内的this和函数外的this 不一致时！ 就不能用箭头函数！\n\n        比如： 对象的方法不能用箭头函数简写\n        \n        比如： DOM中的事件处理函数也不能用箭头函数简写\n')])])]),n("p",[a._v("​"),n("br"),a._v("\n​           问题  一旦改为箭头函数则不能使用arguments")]),a._v(" "),n("h2",{attrs:{id:"for-of"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#for-of"}},[a._v("#")]),a._v(" for of")]),a._v(" "),n("p",[a._v("什么是 在特定情况下专门简化for循环")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("        总结:  遍历一个数组：\n  \n            1.for(var i=0;i<arr.length;i++){\n                ....\n            }\n              优点: 即可控制遍历的方向 有可遍历循环的步调\n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​                2.arr.forEach((elem,i,arr)=>{\n​                  //当前元素 elem\n​                });\n​"),n("br"),a._v("\n局限: 不能控制遍历的方向 也不能控制便利的步调")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("            3. for of\n                  如何:for(var elem of 数组){\n                    \n                    //of 会依次取出数组每个元素值，保存在of前的变量elem中\n                  \n                  }  \n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​                  局限: 只能获得元素值 无法获得当前元素位置\n​"),n("br"),a._v("\n其实 for of 不但可以用于数组 还可以用于字符串,类数组对象,单个数值")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("              总结: for of 可以遍历数字下标数组, 类数组对象,字符串 中的每个字。\n\n              for in 专门遍历自定义下标的关联数组 和对象。\n")])])]),n("h2",{attrs:{id:"参数增强"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参数增强"}},[a._v("#")]),a._v(" 参数增强")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    什么是:ES6中对函数的参数 提供了更强大,更方便的功能\n")])])]),n("p",[a._v("包括:")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("参数默认值(default);")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(' function 函数名(形参,..,形参n=默认值){\n   如果没有传入最后一个参数 则使用默认值作为备胎 \n }  \n ES5 的代替方式:形参 n=形参n||默认值\n 如果形参n是有意义的值不是false"",undefined,null,NaN 就用 形参n 的值继续向后执行\n\n // 如果 形参n是没有意义的值 就用默认值作为备胎\n\n 强调: 局限 只能解决最后一个形参不确定的情况。\n')])])])]),a._v(" "),n("li",[n("p",[a._v("剩余参数(rest);")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" 什么是:专门代替arguments\n 为什么:arguments的问题:\n   \n   1. 不是纯正的数组类型 用不了数组家的函数\n   \n   2. 不支持箭头函数\n   何时: 今后只要使用arguments的地方都可以使用rest语法代替\n   \n   如何:\n       定义函数时：\n         function fn(形参1,形参2,...数组名){\n   \n           //...后的数组会接住除之前形参外的其他所有剩余实参值\n           \n           // 数组是纯正的数组类型可随意使用数组家的函数\n           //即使fun改为箭头函数 依然可以使用...数组名的rest语法 \n         } \n")])])]),n("p",[a._v("​"),n("br"),a._v("\n3. 打散数组(spead);")]),a._v(" "),n("p",[a._v("为什么:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("     代替apply \n")])])]),n("p",[a._v("apply的问题是 本职工作不是打散数组，而是替换this 顺便打散数组。")]),a._v(" "),n("p",[a._v("何时:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("     今后只要希望将一个数组整体 打散为单个值\n")])])]),n("p",[a._v("如何： 传递参数或赋值时")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("     fun(..arr)\n     先将arr中的元素值打散为单个值 再分别传给fun()\n")])])]),n("p",[a._v("项目中:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("   1. 拼接两个数组\n       var arr1 = [1,2,3],arr2=[4,5,6];\n       var arr = [...arr1,arr2];\n       arr=[1,2,3,4,5,6]\n   2. 合并两个对象\n       var obj1={x:1},obj2={b:2};\n       var  obj = {...obj1,...obj2}\n       obj:{x:1,b:2};\n")])])]),n("p",[a._v("解构:")]),a._v(" "),n("p",[a._v("什么是:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("   将一个大的对象或数组中的个别成员 提取出来,单独使用\n")])])]),n("p",[a._v("何时:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("   如果给的是一个巨大的对象,而我们这个功能，\n  只需要其中个别函数或者属性时 就要将所需的成员解构 出来 单独使用。\n")])])]),n("p",[a._v("如何：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("       1 数组解构：\n           什么是: 将大的数组中的个别元素提取出来单独使用。\n           如何:下标对下标\n               [变量1,变量2,...]=数组\n                  0     1  ... \n                结果: 变量1 = 数组[0]\n                      变量2 = 数组[1]\n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​            2 对象解构\n​              什么是: 将大的数组中的个别元素提取出来单独使用\n​"),n("br"),a._v("\n如何： 属性名对属性名\n{属性名1:变量1,属性名 2: 变量2,...}=对象")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("               结果: 变量1=对象.属性名 1\n               \n               变量2 = 对象.属性名2\n               \n         简写 如果新变量的名字延用成员对象中的属性名,则可以简写 \n               \n               比如:user 对象中 解构出登录方法和注册方法单独使用\n \n               var {signin:signin,signup:signup}=user\n               可简写:\n               var {signin,signup} =user; \n")])])])])]),a._v(" "),n("h2",{attrs:{id:"参数结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参数结构"}},[a._v("#")]),a._v(" 参数结构")]),a._v(" "),n("p",[a._v("什么是")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    在定义函数和调用函数时采用对象结构传递参数。\n")])])]),n("p",[a._v("何时:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    多个形参值不确定有没有 而且有要求实参值与形参值之间必须对应。\n")])])]),n("p",[a._v("为什么:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    默认值: 局限;只有最后一个形参不确定时 才能使用默认值\n    ...rest 和 arguments；局限; 无法让形参值与实参值一一对应。\n")])])]),n("p",[a._v("用对象结构传参:")]),a._v(" "),n("p",[a._v("问题:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    定义函数时只有一个对象形参 将来调用者不知道具体形参个数和名称！\n")])])]),n("p",[a._v("如何：2步")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    1 定义函数时 形参写成对象语法！\n    \n    2 调用函数时 所有实参必须放在一个形参对象结构相同的对象中传入\n")])])]),n("h1",{attrs:{id:"es6-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es6-2"}},[a._v("#")]),a._v(" ES6")]),a._v(" "),n("h2",{attrs:{id:"面向对象上的简化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#面向对象上的简化"}},[a._v("#")]),a._v(" 面向对象上的简化：")]),a._v(" "),n("h3",{attrs:{id:"对单个对象提供了2处简化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对单个对象提供了2处简化"}},[a._v("#")]),a._v(" 对单个对象提供了2处简化")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('  如果对象的属性提供了2处简化\n  \n        1. 如果对象的属性值来自于对象外的变量,且变量名刚好和属性名相同 则不用写两遍相同的名字 只要写一遍即可。\n  \n        2. 所有对象的方法,不再需要写":function"\n            强调:对象的方法去掉:function 不等效于箭头函数 突出的特点 this保持不变！\n            所以 去掉:function,只是单纯的简写 没有任何原理的改变！\n')])])]),n("p",[a._v("​")]),a._v(" "),n("h2",{attrs:{id:"class"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#class"}},[a._v("#")]),a._v(" Class:")]),a._v(" "),n("p",[a._v("什么是:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    集中定义一种类型的所有对象统一属性结构和方法的程序结构。\n")])])]),n("p",[a._v("为什么")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    每一种类型 Array Student Date  都有两部分组成 构造函数+原型对象\n")])])]),n("p",[a._v("构造函数:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      负责定义 子对象统一的属性结构,并且负责创建子对象\n")])])]),n("p",[a._v("原型对象:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('    负责保存所有子对象共有的属性值和方法\n    但是,在ES5中 构造函数和原型对象是分开定义的。 不符合"封装"的要求\n')])])]),n("p",[a._v("何时:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    今后只要希望创建一种自定义类型时 都用class\n")])])]),n("p",[a._v("如何: 3件事")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  1. 用class{}包裹 构造函数和原型对象方法\n \n  2. 构造函数名提升为class名 所有构造函数,从此统一更名为constructor\n  \n  3. 所有放在class中的函数,不需要加类型名.prototype前缀,自动就保存在构造函数的原型对象中。\n")])])]),n("p",[a._v("如何使用 class: 用法和从前的构造函数完全一样！\n原型对象的原理依然保持不变。")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("2. 两种类型间的继承:\n          \n          问题： 两种类型之间包含部分相同的属性结构和方法定义。\n          解决： 定义一个上层的父类型,集中保存两种子类型相同部分。\n          extends\n")])])]),n("h1",{attrs:{id:"promise"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[a._v("#")]),a._v(" Promise:")]),a._v(" "),n("p",[a._v("什么是")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  专门保证多个异步函数 可以顺序执行的机制 而且还防止了回调地狱的问题\n")])])]),n("p",[a._v("何时:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    多个异步调用的函数  要求必须顺序执行！\n")])])]),n("p",[a._v("为什么：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    其实用回调函数，也可以实现多个异步函数,顺序执行 但是 使用回调函数\n    会有回调地狱问题！\n")])])]),n("p",[a._v("问题1  多个异步函数要求顺序执行")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    错误的解决 仅按顺序调用\n          结果 无法保证顺序执行\n          因为 多个异步函数 相当于百米赛跑 每人之各占一条跑道 互相不会等待\n  \n    传统解决办法:使用回调函数\n              \n              1. 在定义函数时 定义一个callback形参变量 \n                  在函数内部 最后一句话执行之后自动调用callback（）\n              \n              2. 在调用函数h时,传入一个函数 函数中包含\n              下一步要执行的操作 ———— 提前托付\n               效果   当前一个函数调用时 暂时不执行 传入的小函数\n               只有前一个函数最后一句话执行完 才自动调用传入的小函数\n               一次保证小函数一定会在异步函数调用完才执行  \n               问题 当连续执行的异步函数非常多时就会形成回调地狱！\n")])])]),n("p",[a._v("解决:ES6 Promise")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("    多个异步函数要求顺序执行\n    \n    .then()能接受下一个.then(),取决于前一个.then()中的函数是否也支持Promise。如果前一个.then()中的函数支持Promise 则.then()可以继续.then()。\n      \n    如果前一个.then()中的函数不支持Promise 则不能继续.then()\n")])])]),n("p",[a._v("前后两个函数间传参:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("      2步:\n  \n      1. 上一步函数中 door(参数值)\n  \n      2. 下一个函数定义时就要定义一个形参准备接\n         原理 当上一个函数调用 door(参数值)时,参数默认值 会顺着.then()交给.then()中的下一个函数的形参变量。\n         在下一个中 就可通过自己的形参变量获得上一步传下来的参数值\n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​      局限：\n​"),n("br"),a._v("\ndoor()中只能传一个变量 如果必须穿多个值 则可以将多个值放在数组或对象中整体传入。")]),a._v(" "),n("p",[a._v("​"),n("br"),a._v("\n错误处理:\n​"),n("br"),a._v("\n​              如何: 任何一个支持 Promise的函数中都有另一扇门 如果当前异步任务执行过程中发生错误就可以从另一扇门出来 一旦从报错这扇门出来后,后续.then()都不再执行")]),a._v(" "),n("p",[a._v("​"),n("br"),a._v("\n​            其实new Promise() 除了.then外 还有另一个方法.catch() 凡是从出错的门出来的代码都进入.catch()中执行错误处理操作\n​"),n("br"),a._v("\n等待多个异步任务完成才执行:\nPromise.all([\n多个支持Promise的函数调用(),\n...,\n...,"),n("br"),a._v("\n]).then(function(){后续操作...})")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("        问题：如果每个异步任务都返回一个接力棒 则如何获得所有接力棒呢？\n\n      解决：.then(function(arr){...})\n          其中 arr数组中保存了Promise.all 中所有异步函数通过door()返回执行结果\n      强调: arr中返回值存储的顺序和异步函数执行完成的顺序无关 只和调用的顺序有关！\n")])])]),n("p",[a._v("​")]),a._v(" "),n("h2",{attrs:{id:"一个promise有三个状态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一个promise有三个状态"}},[a._v("#")]),a._v(" 一个Promise有三个状态")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("            1. pending:挂起 异步任务正在执行还没有执行完\n                            \n            2. resolve:同意 当异步任务执行完,且执行成功,主动调用 door()函数  会将Promise对象的状态 改为 resolve 当Promise对象状态改为resolve 就会自动执行.then()中的函数\n                           \n             3. reject: 拒绝 当异步任务执行完 且执行失败 主动调用err()函数  会将Promise对象的状态 改为reject  当Promise对象的状态 一旦被改为reject后 会自动调用  catch()中的函数\n")])])]),n("p",[a._v("​")]),a._v(" "),n("h2",{attrs:{id:"promise的问题-并没有彻底消灭嵌套"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#promise的问题-并没有彻底消灭嵌套"}},[a._v("#")]),a._v(" Promise的问题 并没有彻底消灭嵌套")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('        比如 .then(weimin) \n            .then(function(){\n                console.log("比赛结束")\n            })\n            .catch(function(err){\n                错误处理\n            })\n')])])]),n("p",[a._v("​"),n("br"),a._v("\n解决:ES7： async  awiat 可按照传统同步指定的\n​"),n("br"),a._v("\n​          代码一样 编写异步代码顺序执行\n​"),n("br"),a._v("\n只要多个异步任务需要顺序执行:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("          (async function(){\n              同步代码;\n              await 异步函数();\n              同步代码\n          })();\n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​        其中 await 可让整段匿名函数自调暂时挂起 等待当前异步函数执行完 在执行后续代码！\n​"),n("br"),a._v("\n强调：es7 的 async 和 await 仅仅简化的是Promise函数 调用的部分。而并没有简化 Promise 函数的定义 且 如果想用await 则异步函数\n必须定义为支持Promise的样式")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("  错误处理 如果await修饰的异步函数 中调用了err()方法 打开了错误的门 则await 会认为是程序错误  \n  \n  应该用 try{}catch(err){}来解决\n  强调: 只有async下的try catch 才能捕获异步任务中的错误 没在async下的Js基础中所学的trycatch是不能捕获异步任务的！因为普通Js基础中的try catch 属于主程序 不会等待异步任务执行 就已经结束了 即使异步任务出错 try catch 因为早就结束了 所以根本捕获不到\n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​      为什么 await 配合 try catch 就可以捕获异步任务中的错误呢？\n​      因为 await 可以留住当前程序中的一切代码 等待异步函数执行完。\n​      try catch 就可能捕获到异步任务中的错误")]),a._v(" "),n("p",[a._v("​")]),a._v(" "),n("p",[a._v("​")]),a._v(" "),n("p",[a._v("​")]),a._v(" "),n("p",[a._v("​")])])}),[],!1,null,null,null);s.default=e.exports}}]);