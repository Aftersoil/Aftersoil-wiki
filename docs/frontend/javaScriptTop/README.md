# JS 正则表达式
概述  正则表达式 专门描述字符串中字符串出现规则的表达式

  ## 正则表达式用于:
1. 验证字符串格式
2. 查找敏感词

## 定义正则表达式

* ### 使用字符集简写
  * 多选一规则匹配
    [备选方案]
    [卧我]
    [0-9] 区间内选一


* ## 其他简写
   1. 匹配一位小写音文字母 [a-z] 共26个
   2. 匹配一位大写音文字母 [A-Z] 共26个
   3. 要匹配一位字母 [A-Za-z] 共52个
   4.  要匹配一位字母或数字 [0-9A-Za-z] 共62个
  ##    5. 要匹配一位汉字 [\u4e00-\u9fa5] 19968~40869 共20902个

            例子:
            利用字符集简写定义车牌号规则
            1. 第一位  1位汉字
            2. 第二位  1位大写字母
            3. 第三位   .
            4. 后五位  每一位 都是一位大写字母或数字 
        
            答案:[\u4e00-\u9fa5][A-Z].[0-9A-Z][0-9A-Z][0-9A-Z][0-9A-Z][0-9A-Z] 


* ###  预定义字符集
      - 要匹配一位数字: \d 等效于[0-9];
      - 要匹配一位字母,数字或:\w 等效于 [0-9A-Za-z];
      - 要匹配一位空字符 \s 可匹配 空格,制表符Tab 等 空白
      - 要匹配所有(通配符)  .

手机号规则可进一步简写:
1[3-8]\d\d\d\d\d\d\d\d\d

* #  数量词
     - 手机号实例   \d{9} 等同于 \d * 9 次
     例 : [3-9]\d{9}  
     - 车牌号简写
     例 : [\u4e00-\u9fa5][A-Z].[A-Z0-9]{5}
* ### 数量词 包含两大类
  1. 有明确数量边界的数量词
  
  
            - 字符集{n} 表示字符集必须重复n次 不能多也不能少
            - 字符集{n,m} 表示字符集至少重复n次 最多重复 m 次
              比如： \d{4,6}
            - 字符集{n,}表示字符集匹配内容至少 重复n 次 多了不限
  
  2. 没有明确数量边界的数量词
    
            - \* 可有可无 多了不限
            - ？ 可有可无 最多一次
            - \+  至少一次 多了不限
            - \s*   \s+  \s?
- 例子:
    匹配手机短信中验证码  连续4为 到 6位的手机号

    正则表达式 大部分情况采用 贪婪模式进行匹配
    尽量匹配最长的关键词

* ## 选择和分组
  1.  选择 指多个子规则选择其一进行匹配
  
           子选择1 | 子选择2
    1.  分组 多个子规则分为一组 再和分组外的规则匹配

      其他规则(多个子规则)
      
      例: ([我卧]|wo)\s*([草艹槽]|cao)
  
    2. 定义完整手机号规则
       
       
            - +86 或 0086
            - (\+86|0086)
            - 至少一个空字符:\s+ 
            - 之前所有可有可无 至少一次()?
            - 1 
            - 3~8 任选其一
            - 0-8
              \\+ 转义字符
          答案: ((\+86|0086)\s+)?1[3-8]/d{9}

    3. 定义完整身份证号规则
       
            - 15位数字 \d{15}
            - 2位数字 \d\d
            - 最后一位:  1位数字 或 X[0-9x]
            - 最后三位 可有可无 虽多一次
          
            定义完整身份证正则
            \d{15}(\d\d[0-9x])?

作业需求:  匹配 "微信","weixin","w x" 等情况 并防止 中间加空格  

* ## 指定匹配位置
  
   - 使用情况  如果只希望匹配特殊位置上的关键词时 就可以使用特殊符号 表示特殊位置
          
          1. ^ 表示字符串开头  
          2. $ 表示字符串结尾
          3. \b 表示单词边界,可匹配: 空格 标点符号 字符串开头和结尾等 可将一个单词与其他单词分割开的符号
      
   
  找到开头和结尾空格
  
    例如 ^\s+$ //错误写法
       
            正确写法     
           ^\s+|\s+$
  
  * 常见面试题   
    
    
          - 找到每个单词的首字母
          - ———— 前边紧挨着的单词边界字母
          ^\b[A-Za-z]

作业需求

  使用正则匹配电子邮件: ___ 记住


* ## String 的正则函数
    - 查找敏感词  4种情况
      
      -  1 查找一个固定的敏感词位置 i;
         
             var i=str.indexOf("敏感词",fromi)
         
            在str中 从 fromi 开始 向后查找下一个“敏感词”的下标位置 i
         
            找到 返回敏感词第一个字的下标位置
            没找到返回 -1  
         
            问题: indexOf 只能查找固定的敏感词 而且不支持正则！

      -  2  用正则表达式 模糊查找多种敏感词
         
         
              -  var i = str.search(/正则/i)
                -  i 不区分大小写
                - 原理和用法几乎相同
                - 差别
                    - 1 用灵活的正则表达式 代替了写死的敏感词 
                    - 2 只有一个参数 不能指定开始的位置 永远只能从头开始找  

* ##  扩展 .test() 
  - test() 方法是正则表达式的一个方法，用于检测一个字符串是否匹配某个模式
  - 如果是则返回 true，否则就返回 false
  - regexp.test(str)
    
        手机号验证：!/^[1][3,4,5,7,8][0-9]{9}$/.test(this.phone)

_____




#   String 正则函数 

## 查找敏感词 
  4种
      
  1. 固定敏感词出现的位置
  
              var i = str.indexOf("敏感词",fromi);
            没有给定值 从0开始找
            没找到返回-1
            问题： 如果换成同音字或拼音,就找不到了

  2. 用正则表达式模糊查找一个敏感词的位置
  
                var i=str.search(/正则表达式/i) 
            问题：只能返回敏感词的位置 不能返回敏感词具体的内容
  
  3. 获取敏感词内容 2种

            - var arr = str.match(/正则/i)
            - 在str中 查找一个符合正则要求的敏感词的内容和位置
            - 返回值 返回一个数组 
            - 没找到 返回null 
            - 如果想获得本次查找的内容 arr[0]  
            - 如果想获得本次查找的位置  arr
          
            ["index"] 必须添加 ""
          
            正则表达式只能匹配一个敏感词 -g 找出所有
          
            str.match(//ig);
              
              问题:  如果match+g 只能返回敏感词内容 无法返回敏感词位置 
              如果只关心 敏感词内容  就使用 match+g 

## 强调 
* #### 如果一个函数有可能返回null! 则使用前必须先验证 是不是null 才能使用  因为null之后 什么都不可以加 null 报错 null. 报错
* ${arr!=null?arr.length:0} 

# Js 底层数组都是关联数组  "" : ""

### arr.length arr["length"]  数字下标不能简写!  与小数点冲突

  4. 既查找每个关键词的内容 又查找关键词的位置
  
            - RegExp对象 exec() 函数

# 替换敏感词 

  1. 简单替换 将所有敏感词替换统一新词  
  
           str = str.replace(/正则/ig,"新词")
         
            坑： 替换后 不报错也替换不成功
         
            因为 字符串都是不可变类型 ！
                 无法对原字符串直接进行修改
                 所有字符串函数 都只能返回修改后的字符串 而保持原字符串不变
            解决 想要获得新值 必须用=接住新值保存到变量中
  2. 高级替换 根据每次找到的敏感词不同 动态选择不同的新词替换！
            
             //replace 会自动在每个找到的关键词上调用一次这个
           
            //回调函数 找到几个词 就反复调用几次 每次调用时 会
           
            //自动将本次找到的关键词传给函数keyword

    2个要求
                    
          function(keyword){
             1 必须有一个参数接住本次找到的一个关键词
          
             2 必须返回处理后的新词
                return keyword.toLocaleUpperCase();
              }
              
            所有形参可自己定义参数名
            补 回调函数 callback 我们自己定义的 但不是我们自己调用去执行 而是交给其他对象去执行

衍生：删除敏感词 其实就是将敏感词替换为""
              
              
        function trim(str){
            return str.replace(/^\s+|\s+$/,"");
            }

3. 切割敏感词
   

什么是 根据指定的切割符 切割成多段字符串
       
    2种: 
    
        1. 简单切割  切割符是固定的
           - var arr = str.split("切割符");
           * 将字符串 str 
        
        2. 复杂切割 : 切割符是变化的 但是有规律的。 
        
           - var arr=str.split(/正则/)
        
           - 例如按照空格进行分割
        
         - 衍深操作：打撒字符串为字符数组

  - 总结：
      - 查找敏感词
          - 1. 查找一个固定的敏感词
          
                   str.indexOf("敏感词",fromi);
          - 2. 使用正则模糊查找一个敏感词位置
                   
               
                   str.search(/正则/i)
          - 
          - 3. 用正则查找一个敏感词的内容
    - 1. 只查找一个敏感词的位置 和内容
         
                       var arr = str.match(/正则/i)
      
    - 2. 查找全部敏感词内容 但无法获取位置
         
              str.match(//ig);
          
          - 4. 既查找每个敏感词内容 又查找每个敏感词的位置


      - 替换敏感词
          - 删除
      - 切割
          - 打撒字符串为字符数组

## RegExp对象:
   * 专门保存一条正则表达式 并提供正则执行查找和验证方法的对象
      何时:
      1. 验证时
      2. 高级查找时
      如何:
      1. 创建对象:2种
          1. 简化版创建
            
                  var reg = /\b[a-z]ig;
              
             何时 如果正则表达式固定不变的w
             问题 不支持动态生成正则表达式
             因为://之间是正则表达式的地盘 js不认识

          2. 用new创建

                  var reg = RegExp("\b[a-z]","ig");

             何时  如果正则表达式需要根据变量数组内容 动态生成！

             因为：这种方法用js认识的""代替了// 而在js中 有很多办法 灵活的拼接想要的字符串 
          

          
      2. RegExp
         1. 验证格式：

            var bool = reg.test(str);
            
      
        用reg规则 检测str 是否符合规则要求 
        返回值：true/false
      
        坑: test 默认只要在str 中找到部分 和 reg 匹配的 就返回true ！ 而不要求 从头到尾匹配
      
      
        ## 解决：凡是验证 都要求从头到尾必须完整匹配  
      
            前加 ^ 结尾加 $ 
      
      意味从头到尾
          
      
            只要使用test 必须使用 前后+^$


# RegExp :

  1.  验正字符串格式 bool= reg.test();
  
  2.  既查找内容 有查找关键词的位置
   
      var arr = reg.exec(str); 
      
     
      在str 中查找下一个关键词的位置和内容
          
      返回值 和match 不加 g 的时候是相同的
            知道到 arr[0:关键词的内容,index: 位置]
            如果没有找到返回null



 ## Function
  ## 什么是：

  用途 保存一段可重用的代码段的程序结构 再起一个名字 

  本质 内存中保存一段代码段的存储空间--
    
  ## 为什么：

    代码重用
    何时 只要一段代码 可能被反复使用 都要定义在一个函数内 再起个名字 今后 用函数名等于用代码段

  如何

  创建函数 3种
     
           1. function 函数名 (形参列表){
              函数体
              return 返回值
           }

  形参是什么

              专门接受 从函数外部传入函数内部数据的变量
  为什么

              有些函数执行时  需要动态获得必须的数据 才能正常执行

  何时

              只要一个函数 必须某些数据 才能正确执行

  返回值

          什么是  一个函数的执行结果
          
          为什么 外部调用者可能需要获得函数执行结果
          
          何时   只要外部调用者 需要获的函数的执行结果
笔试问题

    问题  会被声明提前

  什么是 

  在程序执行前！程序会先将所有var 声明的变量和function声明的函数 提前到当前作用域的顶部集中创建 而(赋值=)留在原地

  所以声明提前是js广受诟病的缺陷

  打乱了程序正常执行的顺序

  3. new 来创建
              
          var fun = new Function("形参1","形参2")
        

  2 赋值方式创建：
           
          var 函数名 = function(形参列表){
              函数体
          }
    
    说明: 赋值方式创建的函数 和声明方式 创建的函数在使用时 都一样
    只不过 在程序开始执行前 赋值方式可避免函数被声明提前 保持了程序原有的执行顺序
    
    揭示: js中其实函数也是一个普通的对象而已,函数名仅仅是一个普通的变量 函数名变量通过对象地址引用着函数对象,每次调用函数名时 通过地址 找到函数对象 再执行其中内容
    
    变量 : 内存中存储一个数据的存储空间 在起一个名字


强调 如果一个函数 只是定义 没有调用 该函数体是不会执行


global["a"];  底层  关联数组


### 重载(overload)
  ## 什么是: 

      多个同名函数 不同形参列表 在调用时根据传入实参列表的不同 动态选择函数执行 
  ## 为什么 

      减少函数个数 减轻调用者的负担
  ## 何时 

      只要一件事 可能根据传入参数的不同  执行不同的逻辑 都要使用重载！

  ## 如何: 

      问题Js不支持标准的重载写法 因为js不允许多个同名函数的存在！

  ## 解决: 
        js中借助于arguments 对象实现重载

  ## 什么是:
        每个函数内自带的 专门接收所有传入函数的实参值列表的数组对象。
    
    函数内自带对象 不用创建可直接拿来使用 接收所有传入函数的实参值 即使没有定义形参变量 或形参变量个数少于传入实参值个数 都没关系
    
    arguments 可接住所有传入函数的实参值 这就是为什么js 中的函数 定义了几个形参和调用了几个实参 毫无关系

# 类数组对象: 

    长得像数组的对象
      像数组 1 小标 2 length
      不是数组 是对象 不是数组家孩子

  ## 何时: 

      只要js中接收不确定个数的参数值 都用arguments.
  ## 如何: 

      1 无论传入多少个参数 都只定义一个函数 
      2 在函数内直接访问 arguments 根据 arguments 不同 动态选择不同的逻辑执行任务。

如果只是部分参数不确定 而且参数赋值给参数时 又要求对应关系怎么办？
        
        cook(,,"面")

  答: 以上传参方式 会报语法错误！因为实参列表不允许出现空值 

  ### 当遇到多个参数不确定有没有 又要要求对应关系时 只能使用对象语法解决

  2 步 
        
1 定义函数时:

          function 函数(形参列表变量){
            // 先判断 obj 对象包含那些属性 不包含那些属性 缺少的属性用默认值代替
            // 函数执行过程中 都从对象里,取实参值使用！
          } 
          
          但是, 我们规定 在将来调用时 实参值都要放在一个对象中传入

2  调用函数时:

                函数名({属性1:实参值1，,属性2:实参值2...});
  ## 优点: 任意参数都可以缺少 都不会报错

1 Test 
      任意参数求和

## 匿名函数
  什么是：
        
        定义函数时 不被任何变量所引用的函数  
          (function(){}());

  为什么： 1 为了节约内存 2 划分临时作用域！
      
  何时：  
           
        1. 如果一个函数只执行一次 
        2. 划分临时作用域！
  如何:
        
        1. 回调函数: 今后大多为匿名函数
        2. 匿名函数自调
        1. 为什么  全局变量 极易被污染！ 今后禁止使用全局变量 !

   匿名函数自调 定义函数后 立即调用函数 调用后立即释放！ 
          
  问题 全局变量极易被污染！又不会自动释放 所以 今后禁止使用全局变量
    
    
    解决 今后js 代码 都要包裹在匿名函数自调用中 
    好处 绝对不会产生全局变量 节约内存又不影响功能执行


# 作用域和作用域链

  ## 作用域(scope):

  什么是
    
    用途: 作用域就是一个变量的可用范围
    本质：作用域是保存变量的一个对象
    为什么： 为了避免不同范围得变量互相干扰!
    包括 JS中只包括2级作用域


​        
​        1. 全局作用域：
​             
              1. 保存任何地方都可以访问到的变量区域
              2. 全局中保存的变量称为全局变量 
              3. 全局变量优点 共用 可反复使用 
              4. 缺点 易被污染 浪费内存


​        
​        2. 函数作用域
​                1. 保存在函数内才可以使用的变量区域
​                2. 函数作用域中保存的变量是局部变量 
​                3. 局部变量优点 仅函数内可用 不会污染全局且用完就释放  不占用内存 
​                4. 缺点 无法重用！


## 程序和函数的执行过程：

1.当程序执行时 先创建全局作用域对象window 

在window中 先保存所有的全局变量 和全局 函数 
     
2. 当定义函数时 每个函数其实都有一个好友列表 暂时包含两项 离自己最近的一项是暂时是空的  距离自己远一些的一项保存着指向window 对象的地址
  
 3. "好友列表"作用是 将来调用函数时,万一缺变量,可按照好友列表的顺序 去朋友中寻找

当调用函数时 会临时创建这次调用函数的函数作用域对象 并在函数作用域对象中添加函数的局部变量 并将函数作用域对象的引用 假如函数的好友列表中最近的一项保存！说明函数和临时创建的函数作用域对象 关系最好！ 缺变量 先找临时创建的函数作用域对象  如果函数作用域对象没有 才被迫找window要

    当函数调用后 临时创建的函数作用域对象被释放 函数作用域对象中的变量同时释放 —————— 这就是为什么局部变量不可重用 的原因！！！



## 作用域链(scopes)

什么是: 

    一个函数可用的所有作用域对象的集合。


普通函数的作用链 在调用时是两个成员
      
        1. 距离自己最近的是临时创建的函数作用域对象
        2.  离自己稍微远一些的是全局作用域对象 window

一个函数的作用域链

             1.  保存着这个函数可用的所有变量
             2.  控制这变量的使用顺序
                 
                 先局部 后全局



# 闭包(closure)
  ## 什么是闭包：

    用途: 
    
      既重用一个变量 有保护这个变量不被污染的一种编程方法
    
    本质: 
        
        外层函数的作用域对象 被内层函数对象引用着 无法释放  这个外层函数的作用域就是闭包对象
    
    为什么: 
    
        全局变量和局部变量的优缺点
        全局变量: 优点 可重用 缺点 极易被污染！;
        局部变量：优点  不会被污染 缺点:不可重用！;

  何时：
      
      今后 只要为一个函数保存一个专属的 可重用的 还不会被外部污染的变量

  


  如何：4步
         
            1. 外层函数包裹要保护的变量和内层函数
               内层函数一定要使用了外层函数的局部变量
            2. 外层函数将内层函数抛到外部
            3. 调用者调用外层函数 获得返回的内层函数对象 保存在变量中。 并反复使用。
            4. 外层定义一个变量接收return出的参数

  闭包是如何形成的
      
      外层函数作用域对象,被内层函数对象引用着无法释放


  闭包的缺点

    1. 比普通函数占用更多内存
    2. 多占用父母函数作用域对象
    3. 闭包不会自动释放 可能造成内存泄漏

  解决: 使用完闭包后 如果不在使用了 要手动释放闭包
        pay = null 


定义一个取号机函数 getNum() 可反复输出一个递增的不重复的数字

var getNum()
getNum();//1
getNum();//2
//试图用同名变量篡改序号为0
xxx=0;
getNum();//3



function fun(){
  var n = 999
  nAdd = function(){n++}
  return function(){
    console.log(n)
  }
}
var getN = fun();
getN();//?
nAdd();
getN();//?

___


# 面向对象 

  什么是对象:
    
    用途: 对象是描述现实中一个具体事物的属性和功能的程序结构
    
    本质： 程序中集中存储一个事物的属性和功能的一块存储空间 再起一个名字

  为什么：
    
      便于大量数据的维护和使用

  什么是面向对象编程：
      
      程序都是先将数据封装在对象中 然后再按需使用对象中的成员。 这样的编程方式 就是面向的对象编程
何时:

      今后所有程序都是用面向对象方式实现的

如何：
      面向对象三步/三大特点: 封装 继承 多态

#  封装 继承 多态
   ## 封装：

  什么是： 

      创建一个对象 集中保存一个事物的属性和功能
  何时：
                  
      - 只要使用面向对象方式编程 都要先将数据和功能封装在对象中 然后再按需使用。

  如何3种：
          
          1.用{} 创建一个对象
                
                      var 对象名={
                          属性名:值,
                          ....
                          方法:function(){
                            
                          }
                      }
  如何访问 
          
          对象名.属性名
          对象名.方法(){}   
  问题：
      
      在对象自己的方法 直接使用属性名却无法访问到自己的属性 报错 属性名未定义

  原因 
      
      所有不带.的变量,默认只能在作用域链中(临时函数作用域和我window)查找。 但是对象中{}又不是作用域 所以对象是不包含在作用域链中的 所以直接使用属性,无法找到藏在对象内的属性的。 不好的解决方法：在属性名前加对象. ,勾引着引擎进入对象中查找属性。

  


  问题：
      
        紧耦合 如果外部修改 内部被迫跟着修改

  解决: 
        松耦合 外部改变 内部d代码不用改变 也能自动适应
        
  # ———— this.属性名

  ## 什么是this:

      在调用函数时 临时指向正在调用函数的.前对象的关键词
    
      总结 只要是自己的方法 想访问自己的属性就使用this

  错误：

    函数定义在哪个对象中 this就指向哪个对象 

  正确： 
      this与函数定义在哪无关！只与函数调用这一瞬间.前对象有关


        2.   用new创建：2步
                1.   先创建空对象 var obj = new Object();
                2.  强行向空对象中添加新属性  
                    1.  obj.属性 = 值
                    2.  obj.方法 = function(){...}
                揭示： 所有js对象底层 都是关联数组。

# 对象 VS 关联数组

## 相同 4 个

                1. 都可以用["成员名"]或.成员名两种方式 访问自己的成员。 .成员名 其实就是["成员名"] 简写 也就是说 .成员名 到底层会被自动翻译成["成员名"]
                
                坑 如果成员名来自于一个变量！ 则不能用".变量"方式访问成员。因为."变量" 会被翻译为["变量"], 出错了 因为变量不可以放在""里！
                解决: 今后只要成员名不是写死的，而是来自于一个变量 只能用[变量], 不带引号的方式访问
    
                2. 都可以被for in循环遍历每个成员
                
                3.  随时可以给数组或对象在任何位置添加新成员,而不会报错！ 而自动创建该成员
                  所以 如果想给一个已创建玩得对象 添加新属性 只有一个野蛮的办法 强行赋值！
    
                4.  访问数组或对象中不存在的位置 不会报错 而是返回undefined！
    
                  不同 类型
                        关联数组: 是数组家的孩子
                        对象 是object 孩子

  问题:   

      只能创建一个对象 如果反复创建 多个相同结构的对象时。
      代码很冗余 不便于维护。

  解决:
    
    用构造函数：
    什么是： 专门描述一类对象统一结构的函数
    为什么:  为了重用对象的结构定义 
    何时： 只要程序中需要反复创建 同一类型的多个对象时。

# 构造函数
      如何: 2步
        1. 定义构造函数来描述一类对象同意结构
            function 类型名(形参1){
              this.属性名 = 形参1;
              this.属性名...形参1;
              this.方法=function(){}
            }
        2. 调用构造函数按照统一结构创建对象  
            var obj = new 类型名(属性值1,);   
            new 的 原理：4件事;
                1. 新建一个空对象
                2. ？
                3. 用new调用构造函数 将构造函数中的this 都吸引到new上!
                  然后通过强行赋 
          问题：构造函数虽然实现了代码重用,但是浪费了内存！

 # 继承

  什么是: 爹的成员 孩子无需重复创建,可直接使用
      
  为什么: 代码重用, 节约内存
        
  何时： 

        只要多个孩子都需要共用的成员,都通过继承使用！
  如何： 
      不用自己设置继承关系！其实js中已经帮我们设置好了继承关系
      
      我们直接使用即可！
               
               1. js实现继承, 都是通过继承原型对象来实现的
                  原型对象：专门集中保存一类对象的共有成员的父对象。
    
                  原型对象是在定义构造函数时,附赠的。只不过暂时是空的
                  如何找到原型对象: 每个构造函数都有一个prototype 指向自己附赠的这个原型对象
                  其实 原型对象中 也有一个constructor属性 指回构造函数
    
                  子对象如何继承父对象:
                  new 的 第2步：让子对象的__proto__属性指向妈妈的原型对象 凡是从__proto__属性值指出的关系,都叫继承关系。
            
            结果： 原型对象中的成员 子对象无需创建 可直接使用！

  如何向原型对象中添加共有成员:

        妈妈.prototype.成员名=值
        比如 向所有学生的共同的爸爸 里强行添加一个公用的方法 intrSelf()
        Student.prototype.intrSelf = function(){
          .... .....
        }
        结果： 凡是 Student 生的孩子 都能.inerSelf()来直接调用爹的函数
          比如  lilei.intrSelf();
        
        妈妈叫爸爸 prototype
        孩子叫爸爸  __proto__ 


​    
## 自有属性 和 共有属性：

           自有属性：保存在子对象中 归对象个人所以有的属性
    
           共有属性：保存在原型对象中,归于多个子对象共有的属性

  获取属性值： 二者没有任何差别  子对象.属性名

  修改属性值:
              
              自有属性,可直接用子对象修改
              比如 lilei.sage++;
              
              共有属性,只能用原型对象修改
              如果强行用子对象.共有属性修改 
              会给这个子对象添加一个同名的自有属性。 从此这个子对象和父对象的属性无关了


  ## 内置对象的原型对象:

          任何一种类型 其实都是由构造函数和原型对象组成。内置类型也是这样。
          Js包括的那些内置类型：
              String Number Boolean
              Array  Date  Math RegExp  Error  Function  Object 
              global  


​        
  ## 所有内置类型也包含构造函数和原型对象：

          构造函数: 创建该类型的子对象
          原型对象：保存该类型的所有子对象共有的方法和属性

比如: Array 类型就包含2部分

    1.数组类型构造函数:
            function Array(){...}
            所以创建数组可以使用new Array()


​            
​    2 数组类型也有一个原型对象 包含所有数组对象公用的函数:
​            为一个类型添加一个共有的自定义函数;
​            何时: 只要项目中 经常对一个类型的对象做一种操作 而这个类型的原型对象中又不包含这种函数。
​    
      如何: 比如:为所有数组添加求和这种函数
            sum
            1 在数组类型的原型对象中添加sum函数
            2 用数组类型的子对象 调用这个sum



# 面向对象 

   ## 继承:

      原型链
            
        什么是: 由多级父对象 逐级继承 形成链式结果
            作用：
             
              1. 保存了一个对象可用的所有成员 
                 将来判断一个对象可以使用那些成员,就看它的原型链
                 上有什么成员
                
                 如果一个成员在子对象的原型链的某个父级对象上 就可以:子对象.成员  访问
                
                 如果一个成员不包含在子对象的原型链的任意一个对象上,就不能用 子对象.成员访问
              
              2. 控制着成员的使用顺序:
                  先自有 再共有！

# 多态
什么是: 
    
      一个函数,在不同情况下表现出不同的状态
包括:

        1.  重载: 根据传入参数的
        2.  重写:
             
          什么是: 在子对象中定义和父对象中成员完全相同的成员 来覆盖父对象的成员  


​          
​          为什么: 从爹继承来的成员不一定都是好用的！


​          
​          何时：只要子对象觉得从爹继承来的不好用就要重写！
​             如何：只要在子对象中定义和父对象同名的成员

console.dir()  //输出对象的存储结构

## 自定义继承:

        何时: 只要觉得现在的爹不好用！就可以用
        如何:
            
            1. 只更换一个对象的爹
                
                子对象__proto__=新爹
                
                问题:__proto__浏览器不推介使用
                
                解决:setPrototypeOf()代替__prpto__ 
                Object.setPrototypeOf(子元素,新爹)
         
      set        of Prototype
      
      设置子元素  的 原型对象 为 新爹
      Object.setPrototypeOf(hmm,father);
         
            2. 同时多个对象的爹
                构造函数.prototype=新老公
                时机: 在创建子对象之前换





# ES5

什么是:
    
    EMAScript 标准的第五个升级版本

为什么:
    
     因为Js这门语言 又很多广受诟病的缺陷

包括哪些新的规则:

      "use strict"
严格模式:
                
  什么是: 
    
      比普通Js运行要求更严格的机制
  为什么:  

      因为Js这门语言 又很多广受诟病的缺陷

  何时：
      
      今后所有Js程序都要在严格模式下！
              
              严格模式的新需求: 
              
              1. 禁止给未声明变量赋值！
                    旧Js 强行给未声明的变量赋值 
                结果: 会自动在全局创建
                      全局污染 内存泄漏
              
                严格Js中 强行给未声明的变量赋值
                结果: 报错:xxx is not undefined!
                避免内存泄漏和全局污染
    
             2. 静默失败升级为错误
                   静默失败:执行不成功 也不报错！
                       极其不便调试
                 严格模式中:静默失败 也会报错！    便于调试
             
             3. 普通函数调用和匿名函数自调中的this不再默认指向window 而是指向undefined
             防止全局污染 内存泄漏  
    
             4. 禁止使用 arguments.callee
                  
                什么是 arguments.callee: 是函数运行时, 专门获得当前正在执行的函数本身。
              
                何时: 递归！        
                  为什么:避免紧耦合 避免在函数内写死函数名。
    
    
    
        问题: 递归效率极低！———— 重复计算量太大
    
    
    
        所以 Es5 严格模式 出于性能考虑 禁用了 arguments.callee 就暗示不推介使用递归算法。
    
    
    
        解决：绝大多数的递归可以找循环代替
    
        为什么:避免紧耦合 避免在函数内写死函数名。
    
    
    
        问题: 递归效率极低！———— 重复计算量太大
    
        所以 Es5 严格模式 出于性能考虑 禁用了 arguments.callee 就暗示不推介使用递归算法。
    
    
        解决：绝大多数的递归可以找循环代替




  ## 保护对象:
        什么是:
            
            控制对象的属性值或对象结构进行的随意篡改
        
        为什么: 
        
            在旧的Js中 对象的属性和结构毫无自保能力。 任何人可在任何时候修改属性值为任何值 也可以随意添加属性和删除属性
       
         何时: 
         
         	需要控制对对象的访问时
    
      如何：2个层面:        


 
        

    1 保护对象的属性
    ES5对对象的属性进行了重新分类
            命名属性: 可用.访问到属性
                又分为:
                    数据属性 实际存储属性值的属性。
           
                    访问器属性 不实际存储属性值,仅提供对另一个数据属性的保护。
                    
            内部属性： 无法用.访问到内部的属性
            
            如何保护数据属性：
                旧js中 数据属性其实就是一个普通的变量 毫无自保能力
            
                ES5 标准中: 每个数据属性都是一个缩微的小对象。 每个小对象中,保存一个属性和三个开关
    
                如何修改属性的小开关来保护一个属性呢
            
                问题: 不能用.直接修改属性对象内部的开关属性！
    
          解决：必须用专用的函数解决
        
                Object.defineProperty(
                    对象名,
                    "属性名",
                    {
                      开关：true/false
                    }
                )
        
        问题:writable和enumerable两个开关,任何人都可以随意开关。所以设置这两个起不到保护作用。


​        
​        解决:  只要设置 writeble 和 enumerable
​        
        都要同时关闭configurable, 目的是禁止修改前两个开关

  解决:
      
       只要设置writable 和 enumerable 都要同时关闭configurable 目的是禁止修改两个开关。 且

  


  ## configurable一旦被改为fals 不可逆！


  问题:
      
       enumerable 只能禁止for in 遍历这个属性 无法阻止用.直接访问这个属性。———— 这是半隐藏 
      解决： 无法解决
      问题： Object.defineProperty()一次只能修改对象中的一个属性。如果外部修改多个属性 就要重复写多遍
      
      解决
      Object.defineProperties(
          对象名,{
            属性名:{
              开关：true/false
            },....
          }
      )
    
    问题: 使用保护属性 规则单调 无法使用自定规则保护属性

解决:使用访问器属性保护数据属性

          什么是访问器属性 自己不保存数据,专门提供对其他数据属性的保护。
  何时：

            只要使用灵活的自定义规则保护数据时 就会要请保镖！
  如何:

          0. 先将要保护的数据属性  隐形埋名, 并且半隐藏！！
          1. 为对象添加访问器属性,保护属性
             
              1 访问器属性要冒名顶替使用原属性名
              2 访问器属性中包含get set两个属性值
              
              get 负责读取受保护的属性值
              set 中负责先验证再修改受保护的属性值
              
              访问器属性不再需要value和writable。 但是需要设置enumerable 和 configurable

  访问器属性如何发挥作用:
      
      
          因为访问器属性是冒名顶替的所以,外人访问器属性时 和 访问普通属性是一样的
          
          只不过访问器属性执行时, 会自动根据外人做到的操作,来选择get和set 来调用 

#  ES5

  保护对象 

    保护对象的属性:
    
    保护对象的结构: 3 个级别
          1. 禁止添加新属性:
                    Object.preventExtensions(obj);
          
                阻止对obj对象添加任何扩展属性 
                原理 每个对象都有一个隐藏的
                
                extensible的属性默认值为true
                preventExtensions(obj)使这个内部隐藏属性改为false
          
          2. 密封：在兼具防扩展的基础上 进一步禁止删除现有属性
              Object.seal(obj);


​          
​    2 件事
​        1. 禁止添加新属性
​          Object的extensible = false 
​       
        2. 禁止删除现有属性
          自动将所有属性的configurable 都改为false！ 从此defineProperties中不需要再重复写 configirable:false!
          其实今后 大多数对象都要密封！ 
          强调： 虽然密封禁止修改结构 但是属性值随便改！


​      
​     3. 冻结： 在兼具密封的基础上 进一步禁止删除现有属性 禁止修改属性值！
​        Object.freesze(obj)


​      
​      3 件事: 
​          
          1. 禁止添加新属性
          
                  obj的extensidle=false
          
          2. 禁止删除现有属性:
            
              自动 将所有的属性的configurable都改为false！
          
          3. 自动将所有属性的writable都改为false。




## Object.create()
函数:没有构造函数的情况下，也想到创建一个子对象    子对象继承的简单写法 
    
    3 件事:  
            1.创建一个新对象
            2. 继承一个父对象
            3. 为新对象添加自有属性
           
    var 子对象 =  Object.create(父对象,{
            // defineProperties
            属性名:{
              value : 属性值,
              writable:true/false,
              enumerable: true/false,
              configurable : true/false
            }
            ......
    }) 

  ## call,apply,bind: 替换this

  何时: 
      
      只要函数执行时 内部this 不是我们想要的
      就可以使用这三个函数 将不想要的this换成任意一个想要的对象。
  如何：
           
      1. call,apply: 在一次调用函数时，临时替换一次this！
            要调用的函数.call(替换this的对象，...)
            强调: 实参值列表必须从第二个值开始。
            因为第一个实参的位置让给了替换this的对象！
      原理: 
            call 更大的作用：可让任何对象去调用原本没有任何关系的一个函数。 —————— 抢

## apply vs call:


        apply 和 call 用法几乎完全一样。只不过,要求所有的实参值都要放在一个数组中整体传入。
    
        执行过程：
          1. 先用第一个参数值对象替换函数中的不想要的this。
          2. 打散数组为多个单独的元素值，分别传给对应的每个形参变量
    
        总结：通常情况下 要替换函数中的this,用call就够了！ 只有实参值类表是放在一个数组中的时候才需要使用apply 先打散再传入函数。

  ## bind

    bind: 不调用函数,而是基于函数,创建一个新函数副本。并永久替换新函数中的this为指定的对象。

  何时: 
      
      今后,如果一个函数需要反复调用，又反复替换其中的this时 都是用 bind() 来创建副本,
                      并永久绑定this

  如何: 
          
          var 新函数 = 旧函数.bind(
              替换this的对象,
              要绑定的实参值,
              ....                                  
          )
结果: 

    1. 新函数的功能和就函数是完全一样的。
    2. 但是新函数中的this和开头部分形参,已被永久替换为固定的对象和固定的参数值。
    3. 今后调用新函数时,只要传入可能变化的剩余几个实参值即可！




  # 数组函数

    1.数组中查找元素: indexOf 
      
      数组中的indexOf 和字符串的 indexOf 完全一样
      var i = arr.indexOf("元素",fromi);
      在arr数组中 从 fromi位置开始 找下一个和指定"元素"相同的元素所在的位置i
          返回值:如果找到 返回 i
                  如果没有找到 返回-1



  判断:
         
    1. 判断数组中是否所有元素都符合要求
          var bool = arr.every(function(value,i,arr){
            //value 当前元素值
            // i 当前索引位置
            // arr 当前数组元素
            return 判断条件;
          })
              
    原理 every 会自动遍历arr中的每个元素。
      
    每遍历一个元素,就会自动调用一次回调函数function。
    
    每次调用function时,自动传入当前正在遍历的元素值和下标位置,以及当前数组对象,每次调function 都会用函数内的条件检查当前元素会否符合要求 
    
    只有当前元素符合要求 才能继续遍历下一个元素。 只要碰一个不符合要求的元素,就立刻退出遍历 返回false。意思是不是所有元素都满足要求。
    如果遍历结束,还没有退出,说明整个数组中都符合要求 整个every(),就返回true
    arr[i+1]


​    
​    2. 判断数组中是否包含符合要求的元素
​          var bool =arr.some(function(value,i,arr ){
​                return 判断条件
​          }); 


​        
​        用法和every完全相同 只不过执行时 只要碰到一个元素判断为true  就不不再遍历,直接返回true。 只有遍历结束 还没有找到判断为true才返回false;


​    
  ## 遍历

        普通遍历: 代替for循环
            for(var i=0;i<arr.length;i++){
                  //i  当前位置 // arr[i] 当前元素值 
            }


​            
​            
​            arr.forEach(function(value,i,arr){
​                  //对当前元素执行的操作！
​            })


​            
​            forEach中自动遍历arr中的每个元素 每遍历一个元素 就在这个元素上自动调用一次回调函数function 自动传入当前元素值给value 当前位置给i 当前数组对象给arr。


​      
​      遍历并复制原数组为新数组 
​              var 新数组=原数组.map(
​                // var newArr=[];//自动
​                // for(var i=0; i<arr.length;i++){}
​                //      arr[i] i this
​                //          ↓  ↓  ↓
​                function(value,i,arr){
​                  return 要放入的新数组中的元素值
​                }
​                //return newArr;//自动
​              )
​        原理:
​            
            1. map 内先自动创建一个新数组
            
            2. 然后才是带着回调函数一起遍历 原数组.自动将回调函数在每个元素上执行一次 将回调函数return的结果 放到新的数组中相同的位置上
            
            3. 遍历结束 返回新数组
        总结:
          
          1. 仅单纯代替 for 循环遍历数组,首选foreach
          
          2. 除非想保护原数组,返回的新数组时 采用map. 


​        
​      过滤和汇总：
​            
            1. 过滤: 复制出原数组中符合条件的元素组成 新数组返回. 原数组保持不变！
                  
                  var 新数组=原数组.filter(
                    function(value,i,arr){
                      return 判断条件
                    }
                  ) 
                  
        原理:
            
            1.先创建一个空数组
            
            2.自动遍历原数组中每个元素 每遍历一个元素 就自动调用一次回调函数 如果当前元素经过回调函数验证,返回true 则加入新数组中 如果当前元素经过回调函数验证 返回false 则不加入新数组.  
            
            3. 遍历结束,返回新数组！


​              
​            2. 汇总： 对数组中的元素内同容进行统计 得出最终结论


​                   
​                    
​                    
//作业
1 如何用ES5实现两种类型的继承 ———— 手写
2 如何 判断一个对象是不是数组 共有几种方法！ 6种以上




# ES6
  ## 什么是:ECMAScript 第6个版本

  优点: 在不改变原理的基础上 简化了Js代码  

  问题: 兼容性 
      
      包括:
    
          let:
              什么是:  专门代替var 来声明变量用
             
              为什么:  var 的问题:
                  1. 声明提前
                  2. 没有块级作用域
             
              何时: 只要声明变量都用 let
             
                  优点：
                      1.阻止了声明提前
                      1. 添加块级作用域
             
              原理: let 其实就是一个匿名自调!
                    且let 为了双保险 其实底层悄悄给变量改了名字


​             
​              let 小脾气
​                  1 在相同作用域/块内，禁止同时let两个同名的变量
​             
                  2 在let a之前到当前作用域顶不允许提前使用 a 变量

  ##  箭头函数:
  什么是  对普通函数声明的简写


          何时： 今后绝大多数匿名函数的创建 都用箭头函数。
    
              如何 3件事
    
                  1 去掉 function 在()和{}之间=>
                  
                  2 如果形参列表只有一个变量 可省略()
                  
                  3 如果函数体只有一句话 可省略{}
                  但是 如果仅有的这句话 还是return 则必须省略return
                  去掉{}时 还要注意去掉语句结尾";"
    
            双刃剑
                
                让函数内外this连通 保持一致。都指向函数外this
            
            结论: 如果希望函数内的this和函数外的this 不一致时！ 就不能用箭头函数！
    
            比如： 对象的方法不能用箭头函数简写
            
            比如： DOM中的事件处理函数也不能用箭头函数简写


​           
​           问题  一旦改为箭头函数则不能使用arguments

## for of  
  什么是 在特定情况下专门简化for循环

            总结:  遍历一个数组：
      
                1.for(var i=0;i<arr.length;i++){
                    ....
                }
                  优点: 即可控制遍历的方向 有可遍历循环的步调


​                
​                2.arr.forEach((elem,i,arr)=>{
​                  //当前元素 elem
​                });
​                
                局限: 不能控制遍历的方向 也不能控制便利的步调
    
                3. for of
                      如何:for(var elem of 数组){
                        
                        //of 会依次取出数组每个元素值，保存在of前的变量elem中
                      
                      }  


​                  
​                  局限: 只能获得元素值 无法获得当前元素位置
​                  
                  其实 for of 不但可以用于数组 还可以用于字符串,类数组对象,单个数值
                  
                  总结: for of 可以遍历数字下标数组, 类数组对象,字符串 中的每个字。
    
                  for in 专门遍历自定义下标的关联数组 和对象。



 ##  参数增强 

        什么是:ES6中对函数的参数 提供了更强大,更方便的功能

  包括:
      
  1. 参数默认值(default);
          
          function 函数名(形参,..,形参n=默认值){
            如果没有传入最后一个参数 则使用默认值作为备胎 
          }  
          ES5 的代替方式:形参 n=形参n||默认值
          如果形参n是有意义的值不是false"",undefined,null,NaN 就用 形参n 的值继续向后执行
        
          // 如果 形参n是没有意义的值 就用默认值作为备胎
        
          强调: 局限 只能解决最后一个形参不确定的情况。

  2. 剩余参数(rest);
          
          什么是:专门代替arguments
          为什么:arguments的问题:
            
            1. 不是纯正的数组类型 用不了数组家的函数
            
            2. 不支持箭头函数
            何时: 今后只要使用arguments的地方都可以使用rest语法代替
            
            如何:
                定义函数时：
                  function fn(形参1,形参2,...数组名){
            
                    //...后的数组会接住除之前形参外的其他所有剩余实参值
                    
                    // 数组是纯正的数组类型可随意使用数组家的函数
                    //即使fun改为箭头函数 依然可以使用...数组名的rest语法 
                  } 

        
      ​          
      3. 打散数组(spead);
      
        为什么:
      
              代替apply 
        apply的问题是 本职工作不是打散数组，而是替换this 顺便打散数组。
      
        何时: 
              
              今后只要希望将一个数组整体 打散为单个值
      
        如何： 传递参数或赋值时
              
              fun(..arr)
              先将arr中的元素值打散为单个值 再分别传给fun()
      
        
      
      
        项目中:
      
            1. 拼接两个数组
                var arr1 = [1,2,3],arr2=[4,5,6];
                var arr = [...arr1,arr2];
                arr=[1,2,3,4,5,6]
            2. 合并两个对象
                var obj1={x:1},obj2={b:2};
                var  obj = {...obj1,...obj2}
                obj:{x:1,b:2};
      
      解构:
          
        什么是: 
            
            将一个大的对象或数组中的个别成员 提取出来,单独使用
      
        何时: 
            
            如果给的是一个巨大的对象,而我们这个功能，
           只需要其中个别函数或者属性时 就要将所需的成员解构 出来 单独使用。
      
        如何：
                
                1 数组解构：
                    什么是: 将大的数组中的个别元素提取出来单独使用。
                    如何:下标对下标
                        [变量1,变量2,...]=数组
                           0     1  ... 
                         结果: 变量1 = 数组[0]
                               变量2 = 数组[1]
      
      
      ​          
      ​            2 对象解构
      ​              什么是: 将大的数组中的个别元素提取出来单独使用
      ​        
                    如何： 属性名对属性名
                        {属性名1:变量1,属性名 2: 变量2,...}=对象
          
                        结果: 变量1=对象.属性名 1
                        
                        变量2 = 对象.属性名2
                        
                  简写 如果新变量的名字延用成员对象中的属性名,则可以简写 
                        
                        比如:user 对象中 解构出登录方法和注册方法单独使用
          
                        var {signin:signin,signup:signup}=user
                        可简写:
                        var {signin,signup} =user; 


##  参数结构
  什么是 
    
        在定义函数和调用函数时采用对象结构传递参数。

  何时: 
        
        多个形参值不确定有没有 而且有要求实参值与形参值之间必须对应。
  为什么:
      
        默认值: 局限;只有最后一个形参不确定时 才能使用默认值
        ...rest 和 arguments；局限; 无法让形参值与实参值一一对应。
  用对象结构传参:

  问题:
        
        定义函数时只有一个对象形参 将来调用者不知道具体形参个数和名称！

  如何：2步
        
        1 定义函数时 形参写成对象语法！
        
        2 调用函数时 所有实参必须放在一个形参对象结构相同的对象中传入





# ES6

   ##  面向对象上的简化：

  ###  对单个对象提供了2处简化

      如果对象的属性提供了2处简化
      
            1. 如果对象的属性值来自于对象外的变量,且变量名刚好和属性名相同 则不用写两遍相同的名字 只要写一遍即可。
      
            2. 所有对象的方法,不再需要写":function"
                强调:对象的方法去掉:function 不等效于箭头函数 突出的特点 this保持不变！
                所以 去掉:function,只是单纯的简写 没有任何原理的改变！


​            
  ## Class:

  什么是:
        
        集中定义一种类型的所有对象统一属性结构和方法的程序结构。

  为什么 
        
        每一种类型 Array Student Date  都有两部分组成 构造函数+原型对象

  构造函数:   

          负责定义 子对象统一的属性结构,并且负责创建子对象
  原型对象: 

        负责保存所有子对象共有的属性值和方法
        但是,在ES5中 构造函数和原型对象是分开定义的。 不符合"封装"的要求

  何时: 
        
        今后只要希望创建一种自定义类型时 都用class

  如何: 3件事
      
      1. 用class{}包裹 构造函数和原型对象方法
     
      2. 构造函数名提升为class名 所有构造函数,从此统一更名为constructor
      
      3. 所有放在class中的函数,不需要加类型名.prototype前缀,自动就保存在构造函数的原型对象中。
  如何使用 class: 用法和从前的构造函数完全一样！
  原型对象的原理依然保持不变。


    2. 两种类型间的继承:
              
              问题： 两种类型之间包含部分相同的属性结构和方法定义。
              解决： 定义一个上层的父类型,集中保存两种子类型相同部分。
              extends


  # Promise: 

  什么是 
          
      专门保证多个异步函数 可以顺序执行的机制 而且还防止了回调地狱的问题

  何时: 
      
        多个异步调用的函数  要求必须顺序执行！

  为什么： 

        其实用回调函数，也可以实现多个异步函数,顺序执行 但是 使用回调函数
        会有回调地狱问题！

  问题1  多个异步函数要求顺序执行
        
        错误的解决 仅按顺序调用
              结果 无法保证顺序执行
              因为 多个异步函数 相当于百米赛跑 每人之各占一条跑道 互相不会等待
      
        传统解决办法:使用回调函数
                  
                  1. 在定义函数时 定义一个callback形参变量 
                      在函数内部 最后一句话执行之后自动调用callback（）
                  
                  2. 在调用函数h时,传入一个函数 函数中包含
                  下一步要执行的操作 ———— 提前托付
                   效果   当前一个函数调用时 暂时不执行 传入的小函数
                   只有前一个函数最后一句话执行完 才自动调用传入的小函数
                   一次保证小函数一定会在异步函数调用完才执行  
                   问题 当连续执行的异步函数非常多时就会形成回调地狱！
  解决:ES6 Promise 
        
        多个异步函数要求顺序执行
        
        .then()能接受下一个.then(),取决于前一个.then()中的函数是否也支持Promise。如果前一个.then()中的函数支持Promise 则.then()可以继续.then()。
          
        如果前一个.then()中的函数不支持Promise 则不能继续.then()

  前后两个函数间传参:

          2步:
      
          1. 上一步函数中 door(参数值)
      
          2. 下一个函数定义时就要定义一个形参准备接
             原理 当上一个函数调用 door(参数值)时,参数默认值 会顺着.then()交给.then()中的下一个函数的形参变量。
             在下一个中 就可通过自己的形参变量获得上一步传下来的参数值


​      
​      局限：
​            
            door()中只能传一个变量 如果必须穿多个值 则可以将多个值放在数组或对象中整体传入。  


​      
  错误处理:
​              
​              如何: 任何一个支持 Promise的函数中都有另一扇门 如果当前异步任务执行过程中发生错误就可以从另一扇门出来 一旦从报错这扇门出来后,后续.then()都不再执行


​           
​            其实new Promise() 除了.then外 还有另一个方法.catch() 凡是从出错的门出来的代码都进入.catch()中执行错误处理操作
​    
          等待多个异步任务完成才执行:
            Promise.all([
              多个支持Promise的函数调用(),
              ...,
              ...,  
            ]).then(function(){后续操作...})
            
            问题：如果每个异步任务都返回一个接力棒 则如何获得所有接力棒呢？
    
          解决：.then(function(arr){...})
              其中 arr数组中保存了Promise.all 中所有异步函数通过door()返回执行结果
          强调: arr中返回值存储的顺序和异步函数执行完成的顺序无关 只和调用的顺序有关！


​          
## 一个Promise有三个状态 

                1. pending:挂起 异步任务正在执行还没有执行完
                                
                2. resolve:同意 当异步任务执行完,且执行成功,主动调用 door()函数  会将Promise对象的状态 改为 resolve 当Promise对象状态改为resolve 就会自动执行.then()中的函数
                               
                 3. reject: 拒绝 当异步任务执行完 且执行失败 主动调用err()函数  会将Promise对象的状态 改为reject  当Promise对象的状态 一旦被改为reject后 会自动调用  catch()中的函数


​                
## Promise的问题 并没有彻底消灭嵌套

            比如 .then(weimin) 
                .then(function(){
                    console.log("比赛结束")
                })
                .catch(function(err){
                    错误处理
                })


​                
  解决:ES7： async  awiat 可按照传统同步指定的
​      
​          代码一样 编写异步代码顺序执行
​            
          只要多个异步任务需要顺序执行:
              
              (async function(){
                  同步代码;
                  await 异步函数();
                  同步代码
              })();


​        
​        其中 await 可让整段匿名函数自调暂时挂起 等待当前异步函数执行完 在执行后续代码！
​    
      强调：es7 的 async 和 await 仅仅简化的是Promise函数 调用的部分。而并没有简化 Promise 函数的定义 且 如果想用await 则异步函数
      必须定义为支持Promise的样式
                            
      错误处理 如果await修饰的异步函数 中调用了err()方法 打开了错误的门 则await 会认为是程序错误  
      
      应该用 try{}catch(err){}来解决
      强调: 只有async下的try catch 才能捕获异步任务中的错误 没在async下的Js基础中所学的trycatch是不能捕获异步任务的！因为普通Js基础中的try catch 属于主程序 不会等待异步任务执行 就已经结束了 即使异步任务出错 try catch 因为早就结束了 所以根本捕获不到


​      
​      为什么 await 配合 try catch 就可以捕获异步任务中的错误呢？
​      因为 await 可以留住当前程序中的一切代码 等待异步函数执行完。
​      try catch 就可能捕获到异步任务中的错误















​             

​              

​          

​       





















